defpackage stz/set-utils :
  import core
  import collections
  import stz/utils

public defn overlap? (a:Tuple<Int>, b:Tuple<Int>) -> True|False :
  val [na, nb] = [length(a), length(b)]
  let loop (i:Int = 0, j:Int = 0) :
    if i < na :
      val ai = a[i]
      let search (l:Int = j, r:Int = nb - 1) :
        if l <= r :
          val m = l + (r - l) >> 1
          val bm = b[m]
          if bm < ai :
            search(m + 1, r)
          else if bm > ai :
            search(l, m - 1)
          else :
            true
        else :
          loop(i + 1, l)

public defn subset? (a:Tuple<Int>, b:Tuple<Int>) -> True|False :
  val [na, nb] = [length(a), length(b)]
  let loop (i:Int = 0, j:Int = 0) :
    if i >= na :
      true
    else :
      val ai = a[i]
      let search (l:Int = j, r:Int = nb - 1) :
        if l <= r :
          val m = l + (r - l) >> 1
          val bm = b[m]
          if bm < ai :
            search(m + 1, r)
          else if bm > ai :
            search(l, m - 1)
          else :
            loop(i + 1, m + 1)

public defn subset? (sa:Seq<Int>, sb:Seq<Int>) -> True|False :
  let loop () :
    if empty?(sa) :
      true
    else if empty?(sb) :
      false
    else :
      val [ai, bj] = [peek(sa), peek(sb)]
      if ai < bj :
        false
      else if bj < ai :
        next(sb)
        loop()
      else :
        next(sa)
        next(sb)
        loop()

public defn union (a:Seqable<Int>, b:Seqable<Int>) -> Seq<Int> :
  generate<Int> :
    val [sa, sb] = [to-seq(a), to-seq(b)]
    while not empty?(sa) and not empty?(sb) :
      val [ai, bj] = [peek(sa), peek(sb)]
      if ai < bj :
        yield(next(sa))
      else if bj < ai :
        yield(next(sb))
      else :
        yield(next(sa))
        next(sb)
    do(yield, sa)
    do(yield, sb)

public defn intersect (a:Seqable<Int>, b:Seqable<Int>) -> Seq<Int> :
  generate<Int> :
    val [sa, sb] = [to-seq(a), to-seq(b)]
    while not empty?(sa) and not empty?(sb) :
      val [ai, bj] = [peek(sa), peek(sb)]
      if ai < bj :
        next(sa)
      else if bj < ai :
        next(sb)
      else :
        yield(next(sa))
        next(sb)

public defn union (elts:Seqable<Seqable<Int>>) -> Seqable<Int> :
  reduce(union, elts)

public defn intersect (elts:Seqable<Seqable<Int>>) -> Seqable<Int> :
  reduce(intersect, elts)
