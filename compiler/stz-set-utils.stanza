defpackage stz/set-utils :
  import core
  import collections
  import stz/utils

public defn overlap? (a:Tuple<Int>, b:Tuple<Int>) -> True|False :
  val [na, nb] = [length(a), length(b)]
  let loop (i:Int = 0, j:Int = 0) :
    if i < na and j < nb :
      val [ai, bj] = [a[i], b[j]]
      if ai < bj : loop(i + 1, j)
      else if bj < ai : loop(i, j + 1)
      else : true

public defn subset? (a:Tuple<Int>, b:Tuple<Int>) -> True|False :
  val [na, nb] = [length(a), length(b)]
  if na <= nb :
    let loop (i:Int = 0, j:Int = 0) :
      if i < na and j < nb :
        val [ai, bj] = [a[i], b[j]]
        if ai < bj :
          false
        else if bj < ai :
          loop(i, j + 1)
        else :
          loop(i + 1, j + 1)
      else :
        i >= na

public defn subset? (sa:Seq<Int>, sb:Seq<Int>) -> True|False :
  let loop () :
    if empty?(sa) :
      true
    else if empty?(sb) :
      false
    else :
      val [ai, bj] = [peek(sa), peek(sb)]
      if ai < bj :
        false
      else if bj < ai :
        next(sb)
        loop()
      else :
        next(sa)
        next(sb)
        loop()

public defn union (a:Seqable<Int>, b:Seqable<Int>) -> Seq<Int> :
  generate<Int> :
    val [sa, sb] = [to-seq(a), to-seq(b)]
    while not empty?(sa) and not empty?(sb) :
      val [ai, bj] = [peek(sa), peek(sb)]
      if ai < bj :
        yield(next(sa))
      else if bj < ai :
        yield(next(sb))
      else :
        yield(next(sa))
        next(sb)
    do(yield, sa)
    do(yield, sb)

public defn intersect (a:Seqable<Int>, b:Seqable<Int>) -> Seq<Int> :
  generate<Int> :
    val [sa, sb] = [to-seq(a), to-seq(b)]
    while not empty?(sa) and not empty?(sb) :
      val [ai, bj] = [peek(sa), peek(sb)]
      if ai < bj :
        next(sa)
      else if bj < ai :
        next(sb)
      else :
        yield(next(sa))
        next(sb)

public defn union (elts:Seqable<Seqable<Int>>) -> Seqable<Int> :
  reduce(union, elts)

public defn intersect (elts:Seqable<Seqable<Int>>) -> Seqable<Int> :
  reduce(intersect, elts)
