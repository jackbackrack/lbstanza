defpackage stz/el :
  import core
  import collections
  import stz/dl-ir
  import stz/el-ir
  import stz/utils
  import stz/algorithms
  import stz/ehier
  import stz/basic-blocks
  import stz/dyn-tree
  import stz/conversion-utils
  import stz/set-utils
  import stz/basic-ops
  import stz/dispatch-dag with:
    prefix(Top) => Dag
  import stz/el-infer with :
    prefix(Input, Block, Ins, Def, Cast,
           Match, Use, Annotation, Inherit) => I
    prefix(Branch) => infer-    

;============================================================
;==================== Drivers ===============================
;============================================================

public defn lower-optimized (epackages:Tuple<EPackage>) -> EPackage :
  ;for p in epackages do :
  ;  dump(p, "logs", "precollapse")
  lower(collapse(epackages), true)

public defn lower-unoptimized (epackage:EPackage) -> EPackage :
  lower(epackage, false)

;============================================================
;========================= Lowering =========================
;============================================================

defstruct FunId :
  name : Symbol
  package : Symbol
  arity : False|Int

defn calc-inlineables (epackage:EPackage) -> IntSet :
  val multi-ids = [ValId(`core, `do)]
  val defn-ids = [ValId(`core, `Range), ValId(`collections, `bsearch)]

  defn match-id? (x:RecId, y:RecId) -> True|False :
    package(x) == package(y) and name(x) == name(y)

  val inlineable-multis = to-intset $ generate<Int> :
    for e in exports(packageio(epackage)) do :
      val rec = rec(e)
      match(rec:MultiRec) :
        yield(n(e)) when any?(match-id?{id(rec), _}, multi-ids)

  println("INLINEABLE-MULTIS %_" % [to-tuple $ inlineable-multis])

  val inlineable-defns = to-intset $ generate<Int> :
    for e in exports(packageio(epackage)) do :
      val rec = rec(e)
      match(rec:FnRec) :
        yield(n(e)) when any?(match-id?{id(rec), _}, defn-ids)

  println("INLINEABLE-DEFNS %_" % [to-tuple $ inlineable-defns])

  val inlineables = 
    to-intset $ generate<Int> :
      for e in exps(epackage) do :
        match(e) :
          (e:EDefmethod) : yield(n(e)) when inlineable-multis[multi(e)]
          (e:EDefn) : yield(n(e)) when inlineable-defns[n(e)]
          (e) : false

  println("INLINEABLE %_" % [to-tuple $ inlineables])
  inlineables

defn lower (epackage:EPackage, optimize?:True|False) -> EPackage :
  val lower-timer = MillisecondTimer("LOWER")
  start(lower-timer)
  ;Reset id generation
  take-ids(epackage)

  ;Current processing package
  var cur-package:EPackage = epackage

  ;Necessary tables
  var iotable:IOTable
  var global-vt:VarTable
  var ehier:EHier
  defn update-tables () :
    iotable = IOTable(packageio(epackage))
    global-vt = GlobalVarTable(cur-package, iotable)
    ehier = EHier(packageio(epackage), iotable)
  update-tables()
  
  ;Run pass
  defn run-pass (pass-name:String, f:EPackage -> EPackage, suffix:String, update-tables?:True|False) :
    within time-ms!(pass-name) :
      cur-package = f(cur-package)
      update-tables() when update-tables?
    ;dump(cur-package, "logs", suffix)
    #if-not-defined(OPTIMIZE) :
      ensure-unique-identifiers!(cur-package)
  defn run-pass (pass-name:String, f:(EPackage, VarTable) -> EPackage, suffix:String, update-tables?:True|False) :
    run-pass(pass-name, f{_, global-vt}, suffix, update-tables?)
  defn run-pass (pass-name:String, f:(EPackage, EHier, VarTable) -> EPackage, suffix:String, update-tables?:True|False) :
    run-pass(pass-name, f{_, ehier, global-vt}, suffix, update-tables?)

  val inlineables = calc-inlineables(epackage)

  val fun-variants = IntTable<HashTable<Tuple<EType>,Int>>()

  defn init-fun-variants (epackage:EPackage) :
    for e in filter-by<EDefn|EDefmethod>(exps(epackage)) do :
      val f = func(e)
      match(f:EFn) :
        if not inlineables[n(e)] :
          val tab = HashTable<Tuple<EType>,Int>()
          tab[a1(f)] = n(e)
          fun-variants[n(e)] = tab

  val specialized-parents = IntTable<Int>()

  val defstruct-table = IntTable<EDefStruct>()

  defn init-defstruct-table (epackage:EPackage) :
    for e in filter-by<EDefStruct>(exps(epackage)) do :
      defstruct-table[n(e)] = e

  val no-inlineables = IntSet()

  ;Dump input
  ;dump(cur-package, "logs", "input")
  run-pass("Map Methods", map-methods, "mapped-methods", false)
  run-pass("Create Closures", create-closures, "closures", false)
  run-pass("Convert Mixes", convert-mixes, "mixes", false)
  run-pass("Insert Guards", insert-guards, "guarded", false)
  run-pass("Elide Checks", elide-checks, "elided", false)
  run-pass("Annotate Live", annotate-live, "live", false)
  if optimize? :
    run-pass("Force Remove Checks", force-remove-checks, "removed-checks", false)
  else :
    run-pass("Convert Checks to Typeof", convert-checks-to-typeof, "typeof", false)
  run-pass("Box Mutables", box-mutables, "boxed", false)
  run-pass("Detect Loops", detect-loops, "looped", false)
  run-pass("Simple Inline", simple-inline, "inlined", false)
  run-pass("Within Package Inline", within-package-inline{_, no-inlineables, { true }, IntSet()}, "wp-inlined", false)
  if optimize? :
    run-pass("Remove Reified Types", force-remove-types, "removed-types", true)
  run-pass("Lambda Lift", lambda-lift, "lambda", true)
  run-pass("Lift Objects", lift-objects, "objlifted", true)
  if optimize? :
    val class-tree = make-class-tree(cur-package)
    val method-table = MethodTable(cur-package, class-tree)
    val changed0? = IntSet()
    val changed1? = IntSet()
    val changed2? = IntSet()
    for e in exps(cur-package) do : match(e:EDefn|EDefmethod) : add(changed0?, n(e))
    spit("out0.txt", cur-package)
    run-pass("Eliminate Dead Code", eliminate-dead-code{_, _, { true }}, "eliminate-dead-code", false)
    init-fun-variants(cur-package)
    update-tables()
    init-defstruct-table(cur-package)
    val new-specializations = IntSet()
    let loop (i:Int = 1, n:Int = 10, enabled?:IntSet = changed0?, changed?:IntSet = changed1?) :
      if n > 0 :
        within time-ms!(string-join $ ["LOOP" i]) :
          println("--- LOOP %_ --- %_ ENABLED?" % [i, to-tuple $ enabled?])
          clear(changed?)
          clear(new-specializations)
          run-pass("Specialize", specialize{_, _, { enabled?[_] }, changed?, fun-variants, new-specializations, specialized-parents}, "specialize", true)
          defn run? (id:Int) : enabled?[id] or new-specializations[id]
          ;spit(to-string("out-sp-%_.txt" % [i]), cur-package)
          run-pass("Resolve Methods", resolve-methods{_, _, method-table, run?, changed?}, "resolved-methods", false)
          ;spit(to-string("out-rm-%_.txt" % [i]), cur-package)
          ;println("RESOLVED METHODS IN %_" % [to-tuple $ changed?])
          run-pass("Within Package Inline", within-package-inline{_, inlineables, run?, changed?}, "wp-inlined", false)
          ;println("INLINED METHODS IN %_" % [to-tuple $ changed?])
          ;spit(to-string("out-il-%_.txt" % [i]), cur-package)
          run-pass("Eliminate Dead Code", eliminate-dead-code{_, _, { changed?[_] }}, "eliminate-dead-code", false)
          ;spit(to-string("out-dc-%_.txt" % [i]), cur-package)
          clear(changed2?)
          run-pass("Shrink Ifs", shrink-ifs{_, _, run?, changed2?}, "shrink-ifs", false)
          ;println("SHRUNK IFS IN %_" % [to-tuple $ changed2?])
          ;spit(to-string("out-fi-%_.txt" % [i]), cur-package)
          run-pass("Constant Fold", constant-fold{_, _, _, defstruct-table, run?, changed2?}, "constant-fold", false)
          ;println("CONSTANT FOLDED IN %_" % [to-tuple $ changed2?])
          ;spit(to-string("out-cf-%_.txt" % [i]), cur-package)
          run-pass("Eliminate Dead Code", eliminate-dead-code{_, _, { changed2?[_] }}, "eliminate-dead-code", false)
          ;spit(to-string("out-ed-%_.txt" % [i]), cur-package)
          run-pass("Despecialize", despecialize{_, _, { changed?[_] }, fun-variants, new-specializations, specialized-parents}, "despecialize", true)
          ;spit(to-string("out-ds-%_.txt" % [i]), cur-package)
          add-all(changed?, changed2?)
        loop(i + 1, n - 1, changed?, enabled?) when not empty?(changed?)
  ;; ;; run-pass("Within Package Top Inline", within-package-top-inline, "wp-top-inlined", false)
  var num-variants:Int = 0
  for kv in fun-variants do :
    val pfid = key(kv)
    val variant-entries = to-tuple $ for t in value(kv) filter : value(t) != pfid
    if length(variant-entries) > 0 :
      println("%_ -> %_" % [pfid, length(variant-entries)])
      for kv in variant-entries do :
        num-variants = num-variants + 1
        println("  %_" % [kv])
  println("NUM-VARIANTS %_" % [num-variants])
  run-pass("Resolve Matches Covereage", resolve-matches-coverage, "resolved-matches-coverage", false)
  run-pass("Lift Closures", lift-closures, "closurelifted", false)
  run-pass("Lift Type Objects", lift-type-objects, "typelifted", false)
  ;; if optimize? :
  ;;   run-pass("Common Subexpression Elimination", common-subexpression-elimination, "common-subexpression-elimination", false)
  ;;   spit("out3.txt", cur-package)

  if optimize? : spit("out.txt", cur-package)

  ;Return processed package
  stop(lower-timer)
  println(lower-timer)
  cur-package

;============================================================
;================= Sanity Checks ============================
;============================================================

defn ensure-unique-labels (b:EBody) :
  val idset = IntSet()
  val non-unique = IntSet()
  for l in filter-by<ELabel>(ins(b)) do :
    if not add(idset, n(l)) :
      add(non-unique, n(l))
  ;Issue errors
  if not empty?(non-unique) :
    fatal $ new Printable :
      defmethod print (o:OutputStream, this) :
        print(o, "The following labels are declared more than once: %," % [non-unique])
        print(o, "\nThe body is as follows:\n%_" % [b])  

defn ensure-unique-identifiers! (epackage:EPackage) :
  ;Check body labels
  defn check-body (e:ELBigItem) :
    do*(check-body, e)
    match(e:EBody) :
      ensure-unique-labels(e)
  check-body(epackage)

  ;Track used and nonused identifiers
  val idset = IntSet()
  val non-unique = IntSet()
  within id = used-ids(epackage) :
    if not add(idset, id) :
      add(non-unique, id)

  ;Issue errors
  if not empty?(non-unique) :
    fatal $ new Printable :
      defmethod print (o:OutputStream, this) :
        print(o, "The following identifiers are declared more than once: %," % [non-unique])
        print(o, "\nThe program is as follows:\n%_" % [epackage])

;============================================================
;===================== Collapsing ===========================
;============================================================
defn collapse (epackages:Tuple<EPackage>) :
  ;Create global rec ids for everything
  val global-rec-ids = HashTable<RecId,Int>()

  ;Driver
  defn driver () :
    create-global-rec-ids()
    val pio = new-packageio()
    val exps* = to-tuple(seq-cat(renamed-exps, epackages))
    EPackage(pio, exps*)

  ;Create global ids
  defn create-global-rec-ids () :
    for e in epackages do :
      for ex in exports(packageio(e)) do :
        global-rec-ids[id(rec(ex))] = uniqueid()

  ;Create new packageio
  defn new-packageio () :
    val exports* = to-tuple $ 
      for e in epackages seq-cat :
        for ex in exports(packageio(e)) seq :
          val n* = global-rec-ids[id(rec(ex))]
          sub-n(ex, n*)
    PackageIO(`prog, [], [], exports*)

  ;Rename one specific package
  defn renamed-exps (epackage:EPackage) :
    val local-table = IntTable-init<Int>(uniqueid{})
    defn lookup-id (n:Int, r:Rec) :
      local-table[n] = global-rec-ids[id(r)]
    for e in imports(packageio(epackage)) do :
      lookup-id(n(e), rec(e))
    for e in exports(packageio(epackage)) do :
      lookup-id(n(e), rec(e))
    defn new-id (n:Int) : local-table[n]
    defn new-id (n:Tuple<Int>) : map(new-id, n)
    defn rename (e:ELItem) -> ELItem :
      match(map(rename, e)) :
        ;Types
        (e:EStructT) : EStructT(new-id(n(e)))
        (e:EOf) : EOf(new-id(n(e)))
        (e:ETVar) : ETVar(new-id(n(e)))
        ;ETExps
        (e:EDefGlobal) : sub-n(e, new-id(n(e)))
        (e:EInit) : sub-n(e, new-id(n(e)))
        (e:EDefn) : sub-n(e, new-id(n(e)))
        (e:EDefmulti) : sub-targs(sub-n(e, new-id(n(e))), new-id(targs(e)))
        (e:EDefmethod) : sub-multi(sub-n(e, new-id(n(e))), new-id(multi(e)))
        (e:EDefStruct) : sub-n(e, new-id(n(e)))
        (e:EExternFn) : sub-n(e, new-id(n(e)))
        (e:EExtern) : sub-n(e, new-id(n(e)))
        (e:EDefType) : sub-children(sub-n(e, new-id(n(e))), new-id(children(e)))
        ;EFunction
        (e:EFn) : sub-args(sub-targs(e, new-id(targs(e))), new-id(args(e)))
        (e:ELocal) : sub-n(e, new-id(n(e)))
        (e:ELocalType) : sub-n(e, new-id(n(e)))
        (e:ELocalFn) : sub-n(e, new-id(n(e)))
        (e:ELocalObj) : sub-n(e, new-id(n(e)))
        (e:EMethod) : sub-thisn(sub-multi(e, new-id(multi(e))), new-id(thisn(e)))
        ;Expressions
        (e:EVar) : sub-n(e, new-id(n(e)))
        (e:ETagof) : sub-n(e, new-id(n(e)))
        (e:EVarLoc) : sub-n(e, new-id(n(e)))
        (e:EField) : sub-n(e, new-id(n(e)))
        (e:ETVarLoc) : sub-n(e, new-id(n(e)))
        (e:ENew) : sub-n(e, new-id(n(e)))
        (e:EObject) : sub-n(e, new-id(n(e)))
        (e:EArray) : sub-n(e, new-id(n(e)))
        (e:EStruct) : sub-n(e, new-id(n(e)))
        (e:ELabel) : sub-n(e, new-id(n(e)))
        (e:EGoto) : sub-n(e, new-id(n(e)))
        (e:EIf) : sub-n2(sub-n1(e, new-id(n1(e))), new-id(n2(e)))
        (e:ENewObject) : sub-n(e, new-id(n(e)))
        (e:EObjectGet) : sub-n(e, new-id(n(e)))
        (e:EObjectTGet) : sub-n(e, new-id(n(e)))
        (e:EClosureGet) : sub-n(e, new-id(n(e)))
        (e:EClosureTGet) : sub-n(e, new-id(n(e)))
        (e:ETypeObject) : sub-n(e, new-id(n(e)))
        (e:ETypeof) : sub-n2(sub-n1(e, new-id(n1(e))), new-id(n2(e)))
        (e:EBranch) : sub-n(e, new-id(n(e)))
        (e:EClosure) : sub-n(e, new-id(n(e)))
        ;Doesn't exist
        (e:EDefClosure) : fatal("Not handled")
        (e:EDefObject) : fatal("Not handled")
        (e:EDefTypeObject) : fatal("Not handled")
        (e:EConstClosure) : fatal("Not handled")
        (e:EConstType) : fatal("Not handled")
        ;Default
        (e) : e        
    seq({rename(_) as ETExp}, exps(epackage))

  ;Launch
  driver()

;============================================================
;====================== Unique IDs ==========================
;============================================================
defn take-ids (epackage:EPackage) :
  take-ids $ generate<Int> :
    used-ids(yield, epackage)

val TAKEN-IDS = IntSet()
var ID-COUNTER:Seq<Int> = to-seq(0 to false)

defn take-ids (ids:Seqable<Int>) :
  clear(TAKEN-IDS)
  add-all(TAKEN-IDS, ids)
  ID-COUNTER = to-seq(0 to false)

defn used-ids (return:Int -> ?, epackage:EPackage) :
  ;Overloading
  defn def (n:Int) : return(n)
  defn def (ns:Tuple<Int>) : do(return, ns)

  ;Look at imports
  for import in imports(packageio(epackage)) do :
    def(n(import))

  ;Look at definitions
  defn scan (e:ELItem) :
    do(scan, e)
    match(e) :
      ;Top Level
      (e:EDefGlobal) : def(n(e))
      (e:EDefn) : def(n(e))
      (e:EDefClosure) : (def(n(e)), def(closure(e)))
      (e:EDefmulti) : (def(n(e)), def(targs(e)))
      (e:EDefmethod) : def(n(e))
      (e:EDefStruct) : def(n(e))
      (e:EExternFn) : def(n(e))
      (e:EDefType) : def(n(e))
      (e:EDefObject) : def(n(e))
      (e:EDefTypeObject) : def(n(e))
      ;Locals
      (e:EFn) : (def(targs(e)), def(args(e)))
      (e:ELocal) : def(n(e))
      (e:ELocalType) : def(n(e))
      (e:ELocalFn) : def(n(e))
      (e:ELocalObj) : def(n(e))
      ;Labels
      (e:ELabel) : def(n(e))
      ;Remaining
      (e) : false
  do(scan, exps(epackage))

;Generates a globally unique id.
defn uniqueid () -> Int :
  for i in ID-COUNTER find! :
    not TAKEN-IDS[i]

;============================================================
;================== Method TArg Mapping =====================
;============================================================

;INPUT:
;  input-xs: The type variables for the method.
;  targs: The types passed to the multi
;OUTPUT: [ys, ytypes]
;  ys: The new type variables for the method
;  xtypes: The values for the old input-xs, expressed in terms of ys.
defn inverse-solve (input-xs:Tuple<Int>, targs:Tuple<EType>) -> [Tuple<Int>, Tuple<EType>] :
  ;Created targs
  val ys = map(uniqueid{}, targs)

  ;Initialize solved table
  val solved = IntTable<ETVar>()
  ;Precise Solutions
  for (t in targs, y in ys) do :
    match(t:ETVar) : set?(solved, n(t), ETVar{y})
  ;Approximate Solutions
  for (t in targs, y in ys) do :
    let loop (t:EType = t) :
      match(t) :
        (t:ETVar) : set?(solved, n(t), ETVar{y})
        (t:EOr) : do*(loop, t)
        (t) : false
  ;Return solutions
  val solns = map(get?{solved, _, ETop()}, input-xs)
  [ys, solns]

defn replace-tvars (f:EFn, xs:Tuple<Int>, ys:Tuple<EType>) :
  val table = to-inttable<EType>(xs,ys)
  defn loop (x:EType) :
    match(x) :
      (x:ETVar) : get?(table, n(x), ETop())
      (x) : map(loop, x)
  map(loop, f)

defn replace-tvars (t:EType, xs:Tuple<Int>, ys:Tuple<EType>) :
  val table = to-inttable<EType>(xs,ys)
  defn loop (x:EType) :
    match(x) :
      (x:ETVar) : get?(table, n(x), ETop())
      (x) : map(loop, x)
  loop(t)

defn map-methods (e:EPackage, gvt:VarTable) :
  ;Return the return type of the given multi with the new
  ;type arguments.
  defn multi-return-type (multi:Int, arity:Int, new-targs:Tuple<Int>) :
    val [a1, a2] = fn-types(gvt, multi, arity, map(ETVar,new-targs))
    a2
    
  defn loop (x:ELBigItem) :
    map{loop, _} $ match(x) :
      (m:EDefmethod) :
        val arity = length(args(func(m)))
        val [targs*, tvals] = inverse-solve(targs(func(m)), targs(m))
        val mrt = multi-return-type(multi(m), arity, targs*)        
        var func*:EFn = replace-tvars(func(m), targs(func(m)), tvals)
        func* = sub-targs(func*, targs*)
        func* = sub-a2(func*, EAnd(a2(func*), mrt))
        EDefmethod(n(m), multi(m), [], func*, lostanza?(m))
      (m:EMethod) :
        val arity = length(args(func(m)))
        val [targs*, tvals] = inverse-solve(targs(func(m)), targs(m))
        val mrt = multi-return-type(multi(m), arity, targs*)
        var func*:EFn = replace-tvars(func(m), targs(func(m)), tvals)
        func* = sub-targs(func*, targs*)
        func* = sub-a2(func*, EAnd(a2(func*), mrt))
        EMethod(multi(m), [], thisn(m), func*)
      (x) :
        x
  map(loop, e)

;============================================================
;===================== Body Buffer ==========================
;============================================================

deftype BodyBuffer
defmulti emit (b:BodyBuffer, x:ELocal|ELocalType|ELocalFn|ELocalObj|EIns) -> False
defmulti to-body (b:BodyBuffer, append-locals?:True|False, append-fns?:True|False, append-objs?:True|False) -> EBody

defn BodyBuffer (body:EBody) :
  val new-locals = Vector<ELocal>()
  val new-localtypes = Vector<ELocalType>()
  val new-localfns = Vector<ELocalFn>()
  val new-localobjs = Vector<ELocalObj>()
  val new-ins = Vector<EIns>()
  new BodyBuffer :
    defmethod emit (this, x:ELocal|ELocalType|ELocalFn|ELocalObj|EIns) :
      val xs = match(x) :
        (x:ELocal) : new-locals
        (x:ELocalType) : new-localtypes
        (x:ELocalFn) : new-localfns
        (x:ELocalObj) : new-localobjs
        (x:EIns) : new-ins
      add(xs, x)
    defmethod to-body (this, append-locals?:True|False, append-fns?:True|False, append-objs?:True|False) :
      defn append?<?T> (append?:True|False, xs:Tuple<?T>, ys:Vector<?T>) :
        if not append? : to-tuple(ys)
        else if empty?(ys) : xs
        else : to-tuple(cat(xs,ys))
      val locals* = append?(append-locals?, locals(body), new-locals)
      val localtypes* = append?(append-locals?, localtypes(body), new-localtypes)
      val localfns* = append?(append-fns?, localfns(body), new-localfns)
      val localobjs* = append?(append-objs?, localobjs(body), new-localobjs)
      val ins* = to-tuple(new-ins)
      EBody(locals*, localtypes*, localfns*, localobjs*, ins*)

defn emit-all (b:BodyBuffer, xs:Seqable<ELocal|ELocalType|ELocalFn|ELocalObj|EIns>) :
  do(emit{b, _}, xs)

defn to-body (b:BodyBuffer) :
  to-body(b, true, true, true)

;============================================================
;=================== Closure Creation =======================
;============================================================
defn create-closures (epackage:EPackage, gvt:VarTable) -> EPackage :
  ;Retrieve an info from the given immediate
  defn first-info (f:EVar|ECurry|EMix) :
    match(f) :
      (f:EVar) : info(f)
      (f:ECurry) : info(x(f))
      (f:EMix) : find({_ is FileInfo}, seq(first-info, funcs(f)))

  ;Key utilities for EVar|ECurry
  defn var-hash (e:EVar|ECurry) :
    match(e) :
      (e:EVar) : n(e)
      (e:ECurry) : 11 * n(x(e)) + hash(targs(e))      
  defn var-equal? (a:EVar|ECurry, b:EVar|ECurry) :
    match(a, b) :
      (a:EVar, b:EVar) : n(a) == n(b)
      (a:ECurry, b:ECurry) : n(x(a)) == n(x(b)) and targs(a) == targs(b)
      (a, b) : false      
  defn var-table<T> () :
    HashTable<EVar|ECurry, T>(var-hash, var-equal?)

  ;Create a trampoline function that calls the given immediate
  ;with known arity.
  defn trampoline-fn (f:EVar|ECurry|EMix, arity:Int, vt:VarTable) :
    defn times<?T> (n:Int, f:() -> ?T) :
      to-tuple(repeatedly(f,n))
    val args = arity * uniqueid
    val [a1, a2] = match(f) :
      (f:EVar|ECurry) : fn-types(vt, f, arity)
      (f:EMix) : [arity * ETop, ETop()]
    EFn(true, [], args, arity * ETop, ETop(),
      EBody([], [], [], [], [
        ETCall(f, map(EVar,args), CallGuarded(a1,a2), first-info(f))])
      false)

  ;Create a trampoline function that calls the given immediate
  ;with unknown (and potentially multiple) arities.
  defn trampoline-fn (f:EVar|ECurry|EMix, vt:VarTable) :
    ;Gather all branches
    val branches = Vector<KeyValue<Int,EVar|ECurry>>()
    let loop (f:EImm = f) :
      match(f) :
        (f:EVar) :
          for a in arities(vt,n(f)) do :
            add(branches, a => f)
        (f:ECurry) :
          for a in arities(vt,n(x(f))) do :
            add(branches, a => f)
        (f:EMix) :
          do(loop, funcs(f))

    ;If there's only one
    if length(branches) == 1 :
      val b = branches[0]
      trampoline-fn(value(b), key(b), vt)
    else :
      EMultifn $ to-tuple $
        for group in group-by(key, value, branches) seq :
          trampoline-fn{_, key(group), vt} $
            switch(length(value(group))) :
              1 : head(value(group))
              else : EMix(to-tuple(value(group)))

  ;Lift all first-class functions in body
  defn analyze-body (top-body:EBody, vt:VarTable) :

    ;Create trampoline table
    val trampoline-table = var-table<Int>()
    val trampolines = IntListTable<ELocalFn>()
    val initialized? = IntSet()
    defn uninitialized-trampolines () :
      for entry in trampolines seq-cat :
        if initialized?[key(entry)] : []
        else : value(entry)

    ;Lift all first-class functions in body to trampolines
    defn lift-trampolines (e:ELBigItem, top?:True|False) :
      match(map(lift-trampolines{_, false}, e)) :
        (e:EBody) :
          ;New definitions
          val buffer = BodyBuffer(e)

          ;Retrieve the wrapped identifier in EVar|ECurry
          defn var-id (e:EVar) : n(e)
          defn var-id (e:ECurry) : var-id(x(e))          
          defn lift (x:EVar|ECurry|EMix) -> EVar :
            ;Closure is (conservatively) allocated at use-site if it is a EMix
            ;or if it curries over type variables.
            val allocate-at-use-site? = match(x) :
              (x:EMix) : true
              (x:ECurry) : any?(has-tvar?, targs(x))
              (x:EVar) : false
            ;If at use-site, then init here, otherwise lift to trampoline table
            if allocate-at-use-site? :
              val v = uniqueid()
              emit(buffer, ELocalFn(v, trampoline-fn(x, vt)))
              emit(buffer, EInitClosures([EVarLoc(v)], first-info(x)))
              EVar(v)
            else :
              val x = x as EVar|ECurry
              if not key?(trampoline-table, x) :
                val v = uniqueid()
                add(trampolines, var-id(x), ELocalFn(v, trampoline-fn(x, vt)))
                trampoline-table[x] = v
              EVar(trampoline-table[x])

          ;Analyze an immediate, lifting when necessary
          defn lift-imm (x:EImm) :
            match(x) :
              (x:EVar) : lift(x) when function?(vt,n(x)) else x
              (x:ECurry|EMix) : lift(x)
              (x) : x

          ;Analyze all instructions
          for i in ins(e) do :
            val i* = match(i) :
              (i:ECall|ETCall) : sub-ys(i, map(lift-imm,ys(i)))
              (i) : map(lift-imm, i)
            emit(buffer, i*)

          ;Return function with lifted closures
          init-trampolines(to-body(buffer), top?)
        ;Just return if not a body
        (e) : e

    ;Initialize trampolines.
    defn init-trampolines (body:EBody, top?:True|False) :
      val buffer = BodyBuffer(body)
      ;Emit all trampolines for functions
      for f in localfns(body) do :
        for t in trampolines[n(f)] do :
          add(initialized?, n(f))          
          emit(buffer, t)
      ;Emit remaining trampolines
      if top? :
        do(emit{buffer, _}, uninitialized-trampolines())
        val locs = seq(EVarLoc{n(_)}, uninitialized-trampolines())
        if not empty?(locs) :
          emit(buffer, EInitClosures(to-tuple(locs), false))
      ;Emit instructions with added initializations
      for i in ins(body) do :
        match(i:EInitClosures) :
          val xs* = for x in xs(i) seq-cat :
            val ts = seq(EVarLoc{n(_)}, trampolines[n(x)])              
            cat([x], ts)
          emit(buffer, EInitClosures(to-tuple(xs*), info(i)))
        else : emit(buffer, i)
      ;Return body
      to-body(buffer)

    ;Driver
    lift-trampolines(top-body, true)

  ;Recursive Analysis
  defn analyze (x:ELBigItem, vt:VarTable) :
    match(x:EBody) : analyze-body(x, vt)
    else : map(analyze{_, vt}, x)
  map-with-var-table({analyze(_, _) as ETExp}, gvt, epackage)

;============================================================
;===================== Mix Conversion =======================
;============================================================

public defn convert-mixes (epackage:EPackage, gvt:VarTable) :
  ;Analyze a given body
  defn analyze-body (body:EBody, vt:VarTable) :
    ;Create buffer
    val buffer = BodyBuffer(body)

    ;Split a call into a dispatch branch
    defn make-dispatch (Call:(EVarLoc|False, EImm, Tuple<EImm>, CallGuarded, False|FileInfo) -> EIns,
                        x:EVarLoc|False, f:EMix, ys:Tuple<EImm>, info:False|FileInfo, end?:True|False) :
      ;Construct branches and blocks
      val branches = Vector<EBranch>()
      val blocks = Vector<(() -> False)>()
      val refmask = map(reftype?, a1) where :
        val [a1, a2] = fn-types(vt, funcs(f)[0], length(ys))
      val end-lbl = uniqueid()
      for f in funcs(f) do :
        val [a1, a2] = fn-types(vt, f, length(ys))
        val lbl = uniqueid()
        add(branches, EBranch(select(a1,refmask), lbl, false))
        add{blocks, _} $ fn () :
          emit(buffer, ELabel(lbl))
          emit(buffer, Call(x, f, ys, CallGuarded(a1, a2), info))
          emit(buffer, EGoto(end-lbl)) when not end?
      ;Yield branches
      emit(buffer, EDispatch(select(ys,refmask), to-tuple(branches), info))
      for b in blocks do : b()
      emit(buffer, ELabel(end-lbl)) when not end?

    ;Scan through instructions
    for i in ins(body) do :
      ;Dispatch needed?
      val dispatch? = match(i:ECall|ETCall) : f(i) is EMix
      if dispatch? :
        match(i) :
          (i:ECall) :
            within (x, f, ys, g, info) = make-dispatch(x(i), f(i) as EMix, ys(i), info(i), false) :
              match(calltype(i):CallGuarded) : ECall(x, f, ys, g, info)
              else : ECall(x, f, ys, calltype(i), info)
          (i:ETCall) :
            within (_, f, ys, g, info) = make-dispatch(false, f(i) as EMix, ys(i), info(i), true) :
              match(calltype(i):CallGuarded) : ETCall(f, ys, g, info)
              else : ETCall(f, ys, calltype(i), info)
      else :
        emit(buffer, i)

    ;Yield new body
    to-body(buffer)

  ;Recursively analyze body
  defn analyze (x:ELBigItem, vt:VarTable) :
    match(map(analyze{_, vt}, x)) :
      (x:EBody) : analyze-body(x,vt)
      (x) : x
  map-with-var-table({analyze(_, _) as ETExp}, gvt, epackage)

;============================================================
;=============== Boundary Guard Derivations  ================
;============================================================
;<DOC>
Philosophy:
- All possible boundary changes are checked.
- There is only one exception: interaction with a LoStanza object
  from within a LoStanza context.

All possible boundary guards:
- EDefn
  - Arguments must be correct type.
- EDefmethod
  - Arguments must be correct type.
- ELocalFn
  - Arguments must be correct type.
- EMethod
  - Arguments must be correct type.
- EVar
  - Variable must be assigned.
  - Variable must have correct type.
- EDef
  - Initializing value must have correct type.
- EStore to EVarLoc
  - Value must have correct type.
- ETCall
  - Arguments must have correct type.
  - Function must have Fn type.
- ECall
  - Arguments must have correct type.
  - Function must have Fn type.
  - If return type is bottom :
    - Call should not return.
  - Otherwise:
    - Return value must have correct type.
- EBranch
  - Arguments must have correct type.
- ECheckLength
  - Expression must have Tuple type.
- EReturn
  - Value must have correct type.

Implementation:
- HiStanza functions :
  - Arguments are checked before call.
  - Return value is checked within function. (Unless tailcall.)
- HiStanza variables :
  - Values are checked before assignment.
;<DOC>
;============================================================
;==================== Boundary Guards =======================
;============================================================

public defn insert-guards (epackage:EPackage, gvt:VarTable) :
  ;Guard expression for body
  defn guard-body (body:EBody, buffer:BodyBuffer, vt:VarTable,
                   lostanza-context?:True|False,
                   return-type:EType|False, function-info:FileInfo|False) :
    ;Buffer for holding label entrance guards
    val entry-blocks = IntTable<List<EIns>>(List())
    defn add-entry (b:Int, i:EIns) : update(entry-blocks, cons{i, _}, b)

    ;Set indicating that a variable was uninitialized
    val uninitialized-vars = IntSet()

    ;Return true if n refers to a reference-typed variable.
    defn refvar? (n:Int) :
      variable?(vt,n) and reftype?(type(vt,n))

    ;Ensure that variable has been set
    defn ensure-vars-set (x:EImm) :
      match(x:EVar) :
        ;Possible unset
        val can-be-unset? =
          if refvar?(n(x)) :
            global?(vt,n(x)) or
            (mutable?(vt,n(x)) and uninitialized-vars[n(x)])
        ;Compute whether to emit check
        val emit-check? =
          if lostanza-context? and lostanza?(vt,n(x)) : false
          else : can-be-unset?
        ;Emit check
        emit(buffer, ECheckSet(x,name(x),info(x))) when emit-check?

    ;Ensure that variables have correct type
    defn ensure-vars-type-consistent (x:EImm) :
      match(x:EVar) :
        ;Possible inconsistent
        val can-be-inconsistent? =
          refvar?(n(x)) and lostanza?(vt,n(x))
        if not lostanza-context? and can-be-inconsistent? :
          val t = type(vt,n(x))
          emit(buffer, ECheck(x, t, GetVarContext(), info(x)))

    ;Emit guards for each instruction
    for ins in ins(body) do :
      ;Ensure that variables have been set
      do*(ensure-vars-set, ins)
      ;Ensure that variables are type-consistent
      do*(ensure-vars-type-consistent, ins)

      match(ins) :
        (ins:EDef) :
          ;Track whether x(ins) can be uninitialized.
          if y(ins) is False :
            add(uninitialized-vars, n(x(ins)))
          ;Guard the initialization value
          if not lostanza-context? and y(ins) is-not False :
            val t = type(vt,n(x(ins)))
            val y = y(ins) as EImm
            emit(buffer, ECheck(y, t, DefContext(), info(ins)))
          ;Initialize x
          emit(buffer, ins)
        (ins:EStore) :
          ;Guard the assigned value
          match(loc(ins)) :
            (l:EVarLoc) :
              val check? =
                if lostanza-context? and lostanza?(vt,n(l)) : false
                else : true
              if check? and refvar?(n(l)) :
                val t = type(vt,n(l))
                emit(buffer, ECheck(y(ins), t, SetContext(), info(ins)))
            (l) : false
          ;Store
          emit(buffer, ins)
        (ins:ECheckLength) :
          if not lostanza-context? :
            val tuple = EOf(n(iotable(vt), CORE-TUPLE-ID))
            emit(buffer, ECheck(y(ins), tuple, DetupleContext(), info(ins)))
          emit(buffer, ins)
        (ins:EReturn) :
          match(return-type:EType) :
            emit(buffer, ECheck(y(ins), return-type, ReturnContext(), function-info))
          emit(buffer, ins)
        (ins:EMatch|EDispatch) :
          val branches* = for b in branches(ins) map :
            if not lostanza-context? :
              for (y in ys(ins), t in types(b)) do :
                if has-tvar?(t) :
                  add-entry(n(b), ECheck(y, t, BranchContext(), info(b)))
            sub-types(b, map(remove-tvars, types(b)))
          emit(buffer, sub-branches(ins, branches*))
        (ins:ELabel) :
          emit(buffer, ins)
          for i in reverse(entry-blocks[n(ins)]) do :
            emit(buffer, i)
        (ins:ECall|ETCall) :
          let :
            if function?(f(ins)) :
              val arity = length(ys(ins))
              val [a1, a2] = fn-types(vt, f(ins) as EVar|ECurry, arity)
              if lostanza-context? and lostanza-function?(f(ins)) :
                unguarded-call(a2)
              else : guard-call(a1, a2)
            else if calltype(ins) is CallGuarded :
              val ct = calltype(ins) as CallGuarded
              if lostanza-context? : unguarded-call(a2(ct))
              else : guard-call(a1(ct), a2(ct))
            else : unguarded-call(EUnknown())
          where :
            defn function? (e:EImm) :
              match(e) :
                (e:EVar) : /function?(vt, n(e))
                (e:ECurry) : /function?(vt, n(x(e)))
                (e) : false
            defn lostanza-function? (f:EImm) :
              match(f) :
                (f:EVar) : lostanza?(vt, n(f))
                (f:ECurry) : lostanza?(vt, n(x(f)))
            defn guard-call (a1:Tuple<EType>, a2:EType) :
              ;Sanity check
              fatal("Incorrect call type") when calltype(ins) is-not CallGuarded

              match(ins) :
                (ins:ECall) :
                  ;Create a temporary return location
                  ;if there isn't one, and if the function returns.
                  val xloc* = match(x(ins)) :
                    (x:EVarLoc) :
                      x
                    (_:False) :
                      if not bottom?(a2) :
                        val n = uniqueid()
                        emit(buffer, ELocal(n, a2, false))
                        EVarLoc(n)
                  ;Check this variable if it is not false
                  val x* = if not bottom?(a2) :
                    EVar(n(xloc* as EVarLoc))
                  ;Check arguments
                  for (y in ys(ins), t in a1) do :
                    emit(buffer, ECheck(y, t, ArgContext(), info(ins)))
                  ;Check function
                  if not function?(f(ins)) :
                    val t = EOf(n(iotable(vt), CORE-FN-ID))
                    emit(buffer, ECheck(f(ins), t, FuncContext(), info(ins)))
                  ;Make call
                  emit(buffer, ECall(xloc*, f(ins), ys(ins), CallStanza(), info(ins)))
                  ;Check return type
                  match(x*:EVar) : emit(buffer, ECheck(x*, a2, ReturnContext(), info(ins)))
                  else : emit(buffer, EEnd(info(ins)))
                (ins:ETCall) :
                  ;Check arguments
                  for (y in ys(ins), t in a1) do :
                    emit(buffer, ECheck(y, t, ArgContext(), info(ins)))
                  ;Check function
                  if not function?(f(ins)) :
                    val t = EOf(n(iotable(vt), CORE-FN-ID))
                    emit(buffer, ECheck(f(ins), t, FuncContext(), info(ins)))
                  ;Make call
                  emit(buffer, ETCall(f(ins), ys(ins), CallStanza(), info(ins)))
            defn unguarded-call (a2:EType) :
              val ct* = CallStanza() when calltype(ins) is CallGuarded
                   else calltype(ins)
              emit(buffer, sub-calltype(ins, ct*))
              emit(buffer, EEnd(info(ins))) when bottom?(a2)
        (ins) :
          emit(buffer, ins)

  ;Guard functions
  defn guard-fn (f:EFn, vt:VarTable, lostanza-context?:True|False) -> EFn :
    val buffer = BodyBuffer(body(f))
    for f in localfns(body(f)) do :
      emit(buffer, guard-localfn(f,vt))
    for o in localobjs(body(f)) do :
      emit(buffer, guard-localobj(o,vt))
    val return-type = a2(f) when not lostanza-context?
    guard-body(body(f), buffer, vt, lostanza-context?, return-type, info(f))
    sub-body(f, to-body(buffer, true, false, false))

  defn guard-method (f:EFn, vt:VarTable, lostanza-context?:True|False) -> EFn :
    val buffer = BodyBuffer(body(f))
    for f in localfns(body(f)) do :
      emit(buffer, guard-localfn(f,vt))
    for o in localobjs(body(f)) do :
      emit(buffer, guard-localobj(o,vt))
    if not lostanza-context? :
      for (v in args(f), t in a1(f)) do :
        if has-tvar?(t) :
          emit(buffer, ECheck(EVar(v), t, ArgContext(), info(f)))
    guard-body(body(f), buffer, vt, lostanza-context?, a2(f), info(f))
    val body* = to-body(buffer, true, false, false)
    val a1* = map(remove-tvars, a1(f))
    EFn(tail?(f), targs(f), args(f), a1*, a2(f), body*, info(f))

  defn map-fns<?T> (f:EFn -> EFn, x:?T&ELBigItem) -> T :
    val result = let loop (x:ELBigItem = x) :
      match(x:EFn) : f(x)
      else : map(loop, x)
    result as T&ELBigItem

  defn guard-localfn (f:ELocalFn, vt:VarTable) :
    ELocalFn(n(f), map-fns(guard-fn{_, vt, false}, func(f)))

  defn guard-localobj (o:ELocalObj, vt:VarTable) :
    val methods* = for m in methods(o) map :
      map-fns(guard-method{_, vt, false}, m)
    ELocalObj(n(o), type(o), methods*)

  defn guard-init (e:EInit, vt:VarTable) -> EInit :
    val buffer = BodyBuffer(body(e))
    for f in localfns(body(e)) do :
      emit(buffer, guard-localfn(f, vt))
    for o in localobjs(body(e)) do :
      emit(buffer, guard-localobj(o,vt))
    guard-body(body(e), buffer, vt, lostanza?(e), false, false)
    val body* = to-body(buffer, true, false, false)
    EInit(n(e), body*, lostanza?(e))

  ;Overall driver
  defn analyze (e:ELBigItem, vt:VarTable) -> ELBigItem :
    match(e) :
      (e:EDefmethod) : map-fns(guard-method{_, vt, lostanza?(e)}, e)
      (e:EMethod) : map-fns(guard-method{_, vt, false}, e)
      (e:EDefn) : map-fns(guard-fn{_, vt, lostanza?(e)}, e)
      (e:EExternFn) : map-fns(guard-fn{_, vt, true}, e)
      (e:EInit) : guard-init(e,vt)
      (e) : e
  map-with-var-table({analyze(_, _) as ETExp}, gvt, epackage)

;============================================================
;=================== Freevar Analysis =======================
;============================================================

defn analyze-freevars<?T> (el:ELBigItem&?T, vt:VarTable) -> T :
  defn analyze-usages (e:EFn) -> EFn :
    ;Gather all uses in the function
    val var-uses = IntSet()
    val tvar-uses = IntSet()

    defn loop (e:ELItem) :
      match(e) :
        (e:EVar|EVarLoc) :
          add(var-uses, n(e))
        (e:ETVar|ETVarLoc) :
          add(tvar-uses, n(e))
        (e:EFn) :
          val free = free(e)
          add-all(var-uses, vars(free))
          add-all(tvar-uses, tvars(free))
        (e) :
          do(loop, e)
    do(loop,e)

    ;Remove all locally defined quantities
    defn remove-all (xs:IntSet, ys:Seqable<Int>) : do(remove{xs, _}, ys)
    remove-all(tvar-uses, targs(e))
    remove-all(tvar-uses, seq(n, localtypes(body(e))))
    remove-all(var-uses, args(e))
    remove-all(var-uses, seq(n, locals(body(e))))
    remove-all(var-uses, seq(n, localfns(body(e))))

    ;Record free
    defn local? (x:Int) : not global?(vt,x)
    defn local? (xs:Seqable<Int>) : to-tuple(filter(local?,xs))
    sub-free(e, Free(local?(var-uses), to-tuple(tvar-uses)))

  ;Recursively analyze usages
  defn analyze (e:ELBigItem) :
    match(map(analyze, e)) :
      (e:EFn) : analyze-usages(e)
      (e) : e
  analyze(el) as ELBigItem&T

;============================================================
;===================== Liveness Annotation ==================
;============================================================

defn annotate-live (epackage:EPackage) -> EPackage :
  defn annotate (e0:ELBigItem) -> ELBigItem :
    val e = map(annotate,e0)
    val annotate? = match(e:EFn) :
      not empty?(args(e))
    if annotate? :
      val e = e as EFn
      val ref-args = to-tuple $
        for (a in args(e), t in a1(e)) seq? :
          if reftype?(t) : One(EVar(a))
          else : None()
      val buffer = BodyBuffer(body(e))
      for i in ins(body(e)) do :
        match(i:ETCall|EReturn|EEnd) :
          emit(buffer, ELive(ref-args))
        emit(buffer, i)
      sub-body(e, to-body(buffer))
    else :
      e
  annotate(epackage) as EPackage

;============================================================
;================= Force Remove Checks ======================
;============================================================

defn force-remove-checks (epackage:EPackage) -> EPackage :
  defn convert-body (e:EBody) :
    val buffer = BodyBuffer(e)
    for i in ins(e) do :
      match(i) :
        (i:ECheck) : false
        (i:ECheckSet) : false
        (i:ECheckLength) : false
        (i) : emit(buffer, i)
    to-body(buffer)
  defn convert (e:ELBigItem) :
    match(map(convert,e)) :
      (e:EBody) : convert-body(e)
      (e) : e
  convert(epackage) as EPackage

;============================================================
;=============== Convert Checks to Typeof ===================
;============================================================

defn convert-checks-to-typeof (epackage:EPackage) -> EPackage :
  defn convert (e0:ELBigItem) :
    val e = map(convert, e0)
    match(e:EBody) :
      val buffer = BodyBuffer(e)
      for i in ins(e) do :
        match(i) :
          (i:ECheck) :
            val t = normalize(type(i))
            match(normalize(type(i))) :
              (t:ETop) :
                false
              (t:EBot) :
                emit(buffer, ECheckFail(t, y(i), ctxt(i), info(i)))
              (t) :
                val pass-lbl = uniqueid()
                val fail-lbl = uniqueid()
                emit(buffer, ETypeof(pass-lbl, fail-lbl, t, y(i)))
                emit(buffer, ELabel(fail-lbl))
                emit(buffer, ECheckFail(t, y(i), ctxt(i), info(i)))
                emit(buffer, ELabel(pass-lbl))
          (i) :
            emit(buffer, i)
      to-body(buffer)    
    else : e
  convert(epackage) as EPackage

;============================================================
;===================== Mutable Boxing =======================
;============================================================

defn box-mutables (epackage:EPackage, gvt:VarTable) -> EPackage :
  val boxed = IntSet()
  defn box (e:ELBigItem, vt:VarTable) -> ELBigItem :
    match(e) :
      (e0:EBody) :
        ;Find all closed-over variables
        val closed-over = IntSet()
        defn add-to-closed (e:ELBigItem) :
          match(e:EFn) : add-all(closed-over, vars(free(e)))
          else : do*(add-to-closed, e)
        do*(add-to-closed, e0)

        ;Add all locally closed-over mutable items to boxed set
        for l in locals(e0) do :
          if mutable?(l) and closed-over[n(l)] :
            add(boxed, n(l))

        ;Recursively analyze sub-bodies
        val e = map(box{_, vt}, e0)

        ;Perform boxing
        val buffer = BodyBuffer(e)

        ;Convert a boxed var retrieval into a BoxGet instruction
        defn retrieve-var (e:EImm) :
          match(e:EVar) :
            if boxed[n(e)] :
              val x = uniqueid()
              emit(buffer, ELocal(x, type(vt, n(e)), false))
              emit(buffer, EBoxGet(EVarLoc(x), e))
              EVar(x)
            else : e
          else : e

        ;Convert instructions for operating with boxed variables
        for i in ins(e) do :
          match(map(retrieve-var, i)) :
            (i:EDef) :
              if boxed[n(x(i))] : emit(buffer,EBox(x(i), y(i)))
              else : emit(buffer,i)
            (i:EStore) :
              match(loc(i)) :
                (x:EVarLoc) : box-store(x) when boxed[n(x)] else std-store()
                (x) : std-store()
              where :
                defn box-store (x:EVarLoc) : emit(buffer,EBoxSet(EVar(n(x)), y(i)))
                defn std-store () : emit(buffer, i)
            (i) :
              emit(buffer,i)

        ;Change local types
        defn change-to-box-type (e:EBody) :
          val locals* = for x in locals(e) map :
            if boxed[n(x)] : ELocal(n(x), EOf(n(iotable(vt),CORE-BOX-ID)), false)
            else : x
          sub-locals(e, locals*)

        ;Return new body
        change-to-box-type(to-body(buffer))
      (e) :
        map(box{_, vt}, e)

  ;Perform freevar analysis and then boxing
  within (texp, vt) = map-with-var-table(gvt, epackage) :
    box(analyze-freevars(texp, vt), vt) as ETExp

;============================================================
;=================== Detect Loops ===========================
;============================================================

defn detect-loops (epackage:EPackage) -> EPackage :
  ;Does the given immediate match the given function id?
  defn matches-fid? (e:EImm, fid:Int|False) :
    match(e) :
      (e:EVar) : n(e) == fid
      (e:ECurry) : n(x(e)) == fid
      (e) : false

  ;Scan the given body for tail calls
  defn has-loop? (e:EFn, fid:Int) :
    if empty?(targs(e)) :
      val farity = length(args(e))
      for i in ins(body(e)) any? :
        match(i:ETCall) :
          matches-fid?(f(i), fid) and
          length(ys(i)) == farity

  ;Transform tail calls
  defn transform-loops (e:ELBigItem, fid:Int|False) -> ELBigItem :
    ;First recursively evaluate all the subfunctions in the item, then
    ;work on the transformations.
    ;If we need to transform the body, then:
    ;- Introduce dummy expressions for the arguments and type arguments.
    ;- Introduce the loop label
    ;- Copy the dummy arguments into the real arguments
    ;- Scan through the instructions and generate the looping instructions when necessary.

    ;Recursively evaluate all the subfunctions in the item
    defn recurse () :
      val fid* = match(e) :
                   (e:ELocalFn) : n(e)
                   (e:EDefn) : n(e)
                   (e) : fid
      map(transform-loops{_, fid*}, e)

    ;Detect any loops in the item, and transform them
    defn detect-loop (e:ELBigItem) :
      match(e:EFn, fid:Int) :
        if has-loop?(e,fid) : transform-loop(e, fid)
        else : e
      else : e

    ;Transform the given function into a loop
    defn transform-loop (e:EFn, fid:Int) :
      val farity = length(args(e))
      val buffer = BodyBuffer(body(e))

      ;Create dummy arguments
      val targs0 = map(uniqueid{}, targs(e))
      val args0 = map(uniqueid{}, args(e))
      val loop-lbl = uniqueid()
      for (a in args(e), t in a1(e)) do :
        emit(buffer, ELocal(a, t, false))
      for (ta0 in targs0) do :
        emit(buffer, ELocalType(ta0))

      ;Emit loop start and entry prologue
      emit(buffer, ELabel(loop-lbl))
      for (a0 in args0, a in args(e)) do :
        emit(buffer, EDef(EVarLoc(a), EVar(a0)))

      ;Emit instructions and generate looping instructions
      ;for matching tail calls.
      for i in ins(body(e)) do :
        ;Classify the instruction into either a loop call
        ;or a standard instruction.
        defn* classify () :
          match(i:ETCall) :
            if matches-fid?(f(i), fid) and length(ys(i)) == farity :
              loop-call(f(i), ys(i))
            else : standard-ins()
          else : standard-ins()
        ;For standard instructions just emit them to the buffer
        defn standard-ins () :
          emit(buffer, i)
        ;For loop calls, generate the appropriate instructions.
        defn loop-call (f:EImm, ys:Tuple<EImm>) :
          for (a0 in args0, y in ys) do :
            emit(buffer, EDef(EVarLoc(a0), y))
          emit(buffer, EGoto(loop-lbl))
        ;Start with classify
        classify()

      ;Substitute the new body and arguments
      val body* = to-body(buffer)
      sub-args(sub-body(e, body*), args0)

    ;Driver
    detect-loop(recurse())

  ;Transform all functions
  map(transform-loops{_, false}, epackage)

;============================================================
;=================== Simple Inlining ========================
;============================================================

;Utility for deconstructing an immediate into the function called
;and the type arguments.
defn deconstruct-function (f:EImm) -> Maybe<[Int, Tuple<EType>]> :
  match(f) :
    (f:EVar) : One([n(f), []])
    (f:ECurry) : One([n(x(f)), targs(f)])
    (f) : None()

defn increment<?K> (t:Table<?K,Int>, k:K) :
  update(t, {_ + 1}, k)

defn add<?K,?V> (t:Table<?K,List<?V>>, k:K, v:V) :
  update(t, cons{v, _}, k)

defn efns (f:EFunction) :
  match(f) :
    (f:EFn) : [f]
    (f:EMultifn) : funcs(f)

deftype Ctxt <: Hashable&Equalable
defstruct Top <: Ctxt with: (printer => true)
defstruct LocalFn <: Ctxt : (n:Int) with: (printer => true)
defmethod hash (id:Ctxt) :
  match(id) :
    (id:Top) : 0
    (id:LocalFn) : 27 * n(id)
defmethod equal? (a:Ctxt, b:Ctxt) :
  match(a,b) :
    (a:Top, b:Top) : true
    (a:LocalFn, b:LocalFn) : n(a) == n(b)
    (a,b) : false

defstruct InlineFnRec :
  n: Int
  func: EFunction
  level: Int
  parent: Ctxt   

defn inlining-order (return:ELocalFn -> ?, e:ELBigItem) :
  ;Tables for keeping track of all calls
  val callee-count = IntTable<Int>(0)
  val usage-count = IntTable<Int>(0)
  val callers = IntTable<List<Ctxt>>(List())

  ;Table for holding all the defined functions
  val fn-recs = IntTable<InlineFnRec>()
  defn in-fn-table? (n:Int, farity:Int) :
    val f = get?(fn-recs, n)
    match(f:InlineFnRec) :
      for efn in efns(func(f)) any? :
        farity == length(args(efn))

  ;Returns true if a is a child of b
  defn* child? (a:Ctxt, b:Ctxt) :
    if a == b :
      true
    else :
      match(a) :
        (a:LocalFn) :
          val p = parent(fn-recs[n(a)])
          child?(p, b)
        (a:Top) : false
  
  ;Returns the parent of a that lives at the same level as b.
  defn* match-level (a:LocalFn, b:LocalFn) :
    val ar = fn-recs[n(a)]
    val br = fn-recs[n(b)]
    if level(ar) == level(br) :
      a
    else if level(ar) > level(br) :
      match-level(parent(ar) as LocalFn, b)

  ;Loop through each item to fill the above tables
  defn loop (e:ELBigItem, fid:Ctxt, level:Int) :
    ;Register in fn table
    defn register-in-fn-table () :
      match(e:EBody) :
        for f in localfns(e) do :
          fn-recs[n(f)] = InlineFnRec(n(f), func(f), level + 1, fid)
    ;Recursively loop on subitems
    defn recurse () :
      val [fid*, level*] = match(e) :
        (e:ELocalFn) : [LocalFn(n(e)), level + 1]
        (e) : [fid, level]
      do*(loop{_, fid*, level*}, e)
    ;Look for usages
    defn look-for-usages () :
      defn loop (e:ELItem) :
        if e is-not EInitClosures :
          do(loop, e)
        match(e) :
          (e:EVar) :
            increment(usage-count, n(e))
          (e:ECall|ETCall) :
            val f* = deconstruct-function(f(e))
            if not empty?(f*) :
              val [callee, targs] = value!(f*)
              if in-fn-table?(callee, length(ys(e))) :
                increment(callee-count, callee)
                add(callers, callee, fid)
          (e) : false
      match(e:EBody) :
        do(loop, ins(e))

    ;Driver
    register-in-fn-table()
    recurse()
    look-for-usages()

  ;Compute all inlined functions.
  ;Compute all the call graph at each level.
  val inlined? = IntSet()
  val called = IntTable<List<Int>>(List())
  defn compute-inlined () :
    for fid in keys(fn-recs) do :
      if callee-count[fid] == 1 and usage-count[fid] == 1 :
        val callee = LocalFn(fid)
        val caller = head(callers[fid])
        if not child?(caller, callee) :
          add(inlined?, fid)
          match(caller:LocalFn) :
            val parent-caller = match-level(caller, callee)
            match(parent-caller:LocalFn) :
              add(called, n(parent-caller), n(callee))

  ;Order children before roots
  defn post-order (roots:Seqable<Int>, children:Int -> Seqable<Int>) :
    generate<Int> :
      val visited = IntSet()
      defn loop (n:Int) :
        if not visited[n] :
          add(visited,n)
          do(loop, children(n))
          yield(n)
      do(loop, roots)
  
  ;Output the functions in inlining order
  defn compute-inlining-order () :
    defn loop (e:ELBigItem) :
      match(e:EBody) :
        ;Retrieve all the local functions to be inlined
        val inlined-fns = filter({inlined?[_]}, seq(n, localfns(e)))
        val ordered-fns = post-order(inlined-fns, {called[_]})
        for f in ordered-fns do :
          val func = func(fn-recs[f])
          loop(func)
          return(ELocalFn(f, func))
        ;Recurse on non-inlined items
        for f in localfns(e) do :
          loop(f) when not inlined?[n(f)]            
        do(loop, localobjs(e))
      else :
        do*(loop, e)
    loop(e)

  ;Driver
  loop(e, Top(), 0)
  compute-inlined()
  compute-inlining-order()

defn inline-call (buffer:BodyBuffer,
                  ret:EVarLoc|False, f:EFn, call-targs:Tuple<EType>, call-args:Tuple<EImm>,
                  tail?:True|False) :
  ;Utilities for substituting type arguments
  val targ-table = IntTable<EType>()
  for (ta in targs(f), v in call-targs) do :
    targ-table[ta] = v
  defn substitute-targs (x:ELItem) :
    if empty?(call-targs) :
      x
    else :
      match(x) :
        (x:ETVar) : get?(targ-table, n(x), x)
        (x) : map(substitute-targs, x)

  ;Create locals for inlining
  defn create-locals () :
    ;Define locals for arguments
    for (a in args(f), t in a1(f)) do :
      val t* = substitute-targs(t) as EType
      emit(buffer, ELocal(a, t*, false))
    ;Add all locals from function
    do(emit{buffer, substitute-targs(_) as ELocal}, locals(body(f)))
    do(emit{buffer, _}, localtypes(body(f)))
    do(emit{buffer, substitute-targs(_) as ELocalFn}, localfns(body(f)))
    do(emit{buffer, substitute-targs(_) as ELocalObj}, localobjs(body(f)))

  ;Generate instructions
  defn gen-instructions () :
    ;Label for end of function
    val end-lbl = uniqueid()

    ;Put arguments into argument locals
    for (a in args(f), v in call-args) do :
      emit(buffer, EDef(EVarLoc(a), v))

    ;Emit instructions
    for i in ins(body(f)) do :
      match(substitute-targs(i) as EIns) :
        (i:EReturn) :
          if tail? :
            emit(buffer, i)
          else :
            match(ret:EVarLoc) :
              emit(buffer, EDef(ret, y(i)))
            emit(buffer, EGoto(end-lbl))
        (i:ETCall) :
          if tail? :
            emit(buffer, i)
          else :
            match(ret:EVarLoc) :
              emit(buffer, ECall(ret, /f(i), ys(i), calltype(i), info(i)))
            emit(buffer, EGoto(end-lbl))
        (i) :
          emit(buffer, i)

    ;Emit ending label
    if not tail? :
      emit(buffer, ELabel(end-lbl))

  ;Create locals
  create-locals()
  gen-instructions()

defn simple-inline (epackage:EPackage) :
  defn inline-texp (e:ETExp) :
    ;Inlining a single function
    ;Table for holding inlined functions
    val inlined-functions = IntTable<ELocalFn>()
    defn get-inlined-function (fid:Int, arity:Int) :
      if key?(inlined-functions, fid) :
        val efns = efns(func(inlined-functions[fid]))
        for f in efns find :
          arity == length(args(f))
          
    ;Inlining of a body
    defn inline (e:ELBigItem) :
      match(e:EBody) :
        val buffer = BodyBuffer(e)
        for l in localfns(e) do :
          if not key?(inlined-functions, n(l)) :
            emit(buffer, inline(l) as ELocalFn)
        for o in localobjs(e) do :
          emit(buffer, inline(o) as ELocalObj)
        for i in ins(e) do :
          match(i) :
            (i:ECall|ETCall) :
              val f* = deconstruct-function(f(i))
              if empty?(f*) :
                emit(buffer, i)
              else :
                val [fid, targs] = value!(f*)
                match(get-inlined-function(fid, length(ys(i)))) :
                  (func:EFn) :
                    val [ret, tail?] = match(i) :
                      (i:ECall) : [x(i), false]
                      (i:ETCall) : [false, true]
                    inline-call(buffer, ret, func, targs, ys(i), tail?)
                  (_:False) :
                    emit(buffer, i)
            (i:EInitClosures) :
              val xs* = for x in xs(i) filter : not key?(inlined-functions, n(x))
              if not empty?(xs*) :
                emit(buffer, EInitClosures(to-tuple(xs*), info(i)))
            (i) :
              emit(buffer, i)
        to-body(buffer, true, false, false)
      else :
        map(inline, e)

    ;Inline in the proper inlining order
    within f = inlining-order(e) :    
      val f* = inline(f) as ELocalFn
      inlined-functions[n(f*)] = f*
      
    ;Inline the top level
    inline(e) as ETExp

  ;Inline all top-level expressions
  sub-exps(epackage, map(inline-texp, exps(epackage)))

;============================================================
;================== within-package-inline ===================
;============================================================

defn num-reads (epackage:EPackage, enabled?:Int -> True|False) -> IntTable<Int> :
  val num-reads = IntTable<Int>(0)
  defn walk (e:ELItem) :
    match(e) :
      (e:EDefn|EDefmethod|EInit) :
        do(walk, e) when enabled?(n(e))
      (e:EVar) :
        inc(num-reads, n(e))
      (e) :
        do(walk, e)
  do(walk, exps(epackage))
  num-reads

defn within-package-inline (epackage:EPackage, inlineables:IntSet, enabled?:Int -> True|False, changed?:IntSet) :
  ;Table for holding inlined functions
  val inlined-functions = IntTable<ELocalFn|EDefn|EDefmethod>()
  defn add-to-inline-table (l:ELocalFn|EDefn|EDefmethod) :
    inlined-functions[n(l)] = l
      
  val num-reads = num-reads(epackage, enabled?)

  ;Determine whether a function should be inlined
  defn leaf? (body:EBody) -> True|False :
    not (for i in ins(body) any? : i is ECall|ETCall)
  defn inline? (n:Int, f:EFunction, top?:True|False) :
    match(f) :
      (f:EMultifn) :
        all?(inline?{n, _, top?}, funcs(f))
      (f:EFn) :
        val len = length(ins(body(f)))
        val i? = empty?(localfns(body(f))) and
          empty?(localobjs(body(f))) and
          ((not top? and num-reads[n] == 1) or (len < 8 or (leaf?(body(f)) and len < 11)))
        ;println("INLINE? %_ LEN %_ L? %_ TOP? %_ NUM-READS %_ -> %_" % [n, len, l?, top?, num-reads[n], i?])
        i?

  for exp in exps(epackage) do :
    match(exp:EDefmethod|EDefn) :
      add-to-inline-table(exp) when (inline?(n(exp), func(exp), true) or inlineables[n(exp)])

  defn inline-texp (e:ETExp) :
    ;Inlining a single function
    defn get-inlined-function (fid:Int, arity:Int) :
      if key?(inlined-functions, fid) :
        val efns = efns(func(inlined-functions[fid]))
        for f in efns find :
          arity == length(args(f))

    defn inline (e:ELBigItem, tops:List<Int>) :
      match(e) :
        (e:EBody) :
          ;Add to inline table if appropriate
          for l in localfns(e) do :
            add-to-inline-table(l) when inline?(n(l), func(l), false)
          ;Create buffer
          val buffer = BodyBuffer(e)
          for l in localfns(e) do :
            emit(buffer, inline(l, cons(n(l), tops)) as ELocalFn)
          for o in localobjs(e) do :
            emit(buffer, inline(o, tops) as ELocalObj)
          for i in ins(e) do :
            match(i) :
              (i:ECall|ETCall) :
                val f* = deconstruct-function(f(i))
                if empty?(f*) :
                  emit(buffer, i)
                else :
                  val [fid, targs] = value!(f*)
                  if contains?(tops, fid) :
                    emit(buffer, i)          
                  else:
                    match(get-inlined-function(fid, length(ys(i)))) :
                      (func:EFn) :
                        ; println("----- INLINING %_: %_" % [fid, i])
                        val [ret, tail?] = match(i) :
                          (i:ECall) : [x(i), false]
                          (i:ETCall) : [false, true]
                        for top in tops do : add(changed?, top)
                        inline-call(buffer, ret, rename-fn(func), targs, ys(i), tail?)
                      (_:False) :
                        emit(buffer, i)          
              (i) :
                emit(buffer, i)
          ;Return the body
          to-body(buffer, true, false, false)
        (e:EDefmethod|EDefn|EInit) :
          if enabled?(n(e)) :
            ; println("--- DEFN %_" % [n(e)])
            val res = map(inline{_, cons(n(e), tops)}, e)
            ; if changed?[n(e)] :
            ;   println("--- RES")
            ;   println(res)
            res
          else :
            e
        (e) :
          map(inline{_, tops}, e)        

    ;Inline the top level
    inline(e, List()) as ETExp

  ;Inline all top-level expressions
  ;; println("--- INLINING")
  sub-exps(epackage, map(inline-texp, exps(epackage)))  

;============================================================
;=================== remove-unused-vars =====================
;============================================================

defn remove-unreachable-code (body:EBody) -> EBody :
  val labels = IntTable<Int>()
  for (i in ins(body), j in 0 to false) do :
    match(i:ELabel): labels[n(i)] = j
  val num-gotos = IntTable<Int>(0)
  val walked? = IntSet()
  let loop (pc:Int = 0) :
    defn goto (n:Int) :
      num-gotos[n] = num-gotos[n] + 1
      loop(labels[n])
    if not walked?[pc] and pc < length(ins(body)) :
      add(walked?, pc)
      val ins = ins(body)[pc]
      ;; walk(ins)
      match(ins) :
        (e:EIf|ETypeof) :          (goto(n1(e)), goto(n2(e)))
        (e:EReturn|EEnd|ETCall) :  false
        (e:EMatch|EDispatch) :     for b in branches(e) do : goto(n(b))
        (e:EGoto) :                goto(n(e))
        (e:EIns) :                 loop(pc + 1)

  ;Remove all dead instructions.
  val new-ins = to-tuple $ for (i in ins(body), j in 0 to false) filter : walked?[j]
  ;Remove goto/label when label immediately follows goto and only one label target.
  val peep-ins = Vector<EIns>()
  val len = length(new-ins)
  let walk (j:Int = 0) :
    if j < len :
      val now-ins = new-ins[j]
      defn walk-nxt () :
        add(peep-ins, now-ins)
        walk(j + 1)
      match(now-ins:EGoto) :
        if j < (len - 1) :
          val nxt-ins = new-ins[j + 1]
          match(nxt-ins:ELabel) :
            if n(now-ins) == n(nxt-ins) and num-gotos[n(nxt-ins)] == 1 :
              walk(j + 2)
            else :
              walk-nxt()
          else:
            walk-nxt()
        else :
          walk-nxt()
      else :
        walk-nxt()

  sub-ins(body, to-tuple $ new-ins)
  ; sub-ins(body, to-tuple $ peep-ins)

defn remove-unreachable-code (e:ETExp) -> ETExp :    
  defn remove-unreachable-code-in-bodies (e:ELBigItem) :
    match(map(remove-unreachable-code-in-bodies, e)) :
      (e:EBody) : remove-unreachable-code(e)
      (e) : e
  remove-unreachable-code-in-bodies(e) as ETExp

defn maybe-side-effecting? (e:EIns) -> True|False :
  e is ETCall|ECall|EGoto|EBoxSet|ECheckFail

defn pure? (ins:EIns) :
  match(ins) :
    (ins:EPrim) : op(ins) is BasicOp and op(ins) is-not GCOp|PrintStackTraceOp|FlushVMOp|CRSPOp
    (ins:EDef|ELoad|EPtr|ENew|ETuple|EVoidTuple|ETupleGet|EObject|EStruct|ENewObject|EObjectGet|EClosureGet|EBox|EBoxGet|EInterpret|EConv) : true
    (ins) : false

defn inc (t:IntTable<Int>, k:Int) -> Int :
  update(t, { _ + 1 }, k)

defn cons!<?T> (t:IntTable<List<?T>>, k:Int, e:?T) -> List<T> :
  update(t, { cons(e, _) }, k)

defn eliminate-dead-code (epackage:EPackage, gvt:VarTable, enabled?:Int -> True|False) -> EPackage :
  val unused-vars = IntSet()
  val num-reads = IntTable<Int>(0)
  val num-writes = IntTable<Int>(0)
  val writers = IntTable<List<EIns>>(List())
  val mut? = IntSet()
  val var-side-effecting? = IntSet()
  val aliases = IntTable<Int>()

  var dtrace? = false

  ;Collect statistics including num-reads/writes on vars
  defn analyze-body (body:EBody, vt:VarTable) :
    for l in locals(body) do : num-reads[n(l)] = 0
    defn walk (e:ELItem, writer:False|EIns) :
      match(e) :
        (e:EVar) :
          if not global?(vt, n(e)) : inc(num-reads, n(e))
        (e:EVarLoc) :
          if not global?(vt, n(e)) :
            match(writer) :
              (writer:EInitClosures) :
                inc(num-reads, n(e))
              (writer:EIns) :
                add(var-side-effecting?, n(e)) when not pure?(writer)
                val nw = inc(num-writes, n(e))
                add(mut?, n(e)) when nw > 1
                cons!(writers, n(e), writer)
              (writer) :
                inc(num-reads, n(e))
        (e:ELive) :
          false
        (e:EPtr|ELoad) :
          walk(loc(e), false)
          walk(x(e),   e)
        (e:EIns) :
          do(walk{_, e}, e)
        (e) :
          do(walk{_, false}, e)

    for ins in ins(body) do : walk(ins, false)

  defn transitively-remove-unused-vars () :
    for kv in num-reads do :
      add(unused-vars, key(kv)) when (value(kv) == 0 and not var-side-effecting?[key(kv)])
    val work = Queue<Int>()
    for v in unused-vars do :
      ; println("ADDING WORK %_" % [v]) when dtrace?
      add(work, v)
    defn dec-num-reads (e:ELItem, lhs?:True|False) :
      match(e) :
        (e:EVarLoc) :
          do(dec-num-reads{_, true}, e) when not lhs?
        (e:EVar|ETagof) :
          defn do-update (m:Int) :
            println("DECing %_ -> %_" % [e, m]) when dtrace?
            if m == 1 and not var-side-effecting?[n(e)] :
              add(work,        n(e))
              println("REMOVING VAR %_" % [n(e)]) when dtrace?
              add(unused-vars, n(e))
            m - 1
          update(num-reads, do-update, n(e))
        (e:EPtr|ELoad) :
          dec-num-reads(loc(e), false)
          dec-num-reads(x(e),   true)
        (e) :
          do(dec-num-reads{_, lhs?}, e)
    while not empty?(work) :
      val unused = pop(work)
      for writer in writers[unused] do :
        println("WRITER OF %_ IS %_" % [unused, writer]) when dtrace?
        do(dec-num-reads{_, false}, writer) when pure?(writer)

  defn unused? (n:Int) : unused-vars[n] and not var-side-effecting?[n]
  defn immutable? (vt:VarTable, n:Int) : not (mut?[n] or mutable?(vt, n))
  
  defn rename-body (body:EBody, vt:VarTable) -> EBody :
    ;Rename all vars through single write defs.
    defn rename (e:EIns) -> EIns :
      defn walk (e:ELItem) :
        match(e) :
          (e:EDef) :
            if unused?(n(x(e))) :
              e
            else :
              match(y(e)) :
                (y:EVar) :
                  if immutable?(vt, n(y)) and immutable?(vt, n(x(e))) :
                    aliases[n(x(e))] = get?(aliases, n(y), n(y))
                    add(unused-vars, n(x(e)))
                  sub-y(e, walk(y) as EVar)
                (y) :
                  e
          (e:EVar|EVarLoc) :
            if key?(aliases, n(e)) :
              sub-n(e, aliases[n(e)])
            else :
              e
          (e:ELive) :
            ELive(to-tuple $ for e in xs(e) filter : not match(e:EVar) : key?(aliases, n(e)))
          (e) :
            map(walk, e)
      walk(e) as EIns
    val renamed-ins = to-tuple $ for i in ins(body) seq : rename(i)

    defn unused-localfn? (n:Int) : num-reads[n] <= 1 ;Has at least InitClosure ref
      
    ;Remove pure ins producing unused vars
    val new-ins = Vector<EIns>()
    for (i in renamed-ins, j in 0 to false) do :
      match(i) :
        (i:EDef|EPrim|ELoad|EPtr|ENew|ETuple|EVoidTuple|ETupleGet|EObject|EStruct|ENewObject|EObjectGet|EClosureGet|EBox|EBoxGet|EInterpret|EConv) :
          add(new-ins, i) when not unused?(n(x(i)))
        (i:EInitClosures) :
          val xs* = for x in xs(i) filter : not unused-localfn?(n(x))
          if not empty?(xs*) :
            add(new-ins, EInitClosures(to-tuple(xs*), info(i)))
        (i:ELive) :
          val vars = to-tuple $ for e in xs(i) filter : not match(e:EVar) : unused?(n(e))
          add(new-ins, ELive(vars)) when not empty?(vars)
        (i) :
          add(new-ins, i)

    val new-locals = to-tuple $ for l in locals(body) filter : unused?(n(l)) == false
    val new-localfns = to-tuple $ for f in localfns(body) filter : (unused-localfn?(n(f)) == false)
    val res = EBody(new-locals, localtypes(body), new-localfns, localobjs(body), to-tuple $ new-ins)

    if dtrace? and (length(ins(body)) != length(ins(res)) or length(locals(body)) != length(locals(res))) :
      println("\n--- STATS --->\n")
      println("MUT: %_" % [to-tuple $ mut?])
      println("NUM-READS: %_" % [to-tuple $ num-reads])
      println("NUM-WRITES: %_" % [to-tuple $ num-writes])
      println("UNUSED-VARS: %_" % [to-tuple $ unused-vars])
      println("UNUSED?: %_" % [to-tuple $ for v in locals(body) seq : n(v) => unused?(n(v))])
      println("NEW-LOCALS: %_" % [to-tuple $ for l in new-locals seq : n(l)])
      for l in new-locals do :
        if unused?(n(l)) != false : println("UNUSED %_ => %_" % [n(l), unused?(n(l))])
      println("NEW-LOCALFNS: %_" % [to-tuple $ for l in new-localfns seq : n(l)])
      println("LOCALS: %_" % [to-tuple $ for l in locals(body) seq : n(l) => unused?(n(l))])
      println("VAR-SIDE-EFFECTING?: %_" % [to-tuple $ var-side-effecting?])
      println("ALIASES: %_" % [to-tuple $ aliases])
      println("\n--- BEFORE --->")
      println(body)
      println("\n--- AFTER --->")
      println(res)
    res


  defn walk-top (x:ELBigItem, vt:VarTable) :
    defn analyze (e:ELItem) :
      match(e) :
        (e:EFn) :
          for arg in args(e) do : num-writes[arg] = 1
          do(analyze, e)
        (e:EBody) :
          analyze-body(e, vt)
          do(analyze, localfns(e))
        (e:EDefn|EDefmethod|EInit) :
          clear(mut?)
          clear(aliases)
          clear(unused-vars)
          clear(num-reads)
          clear(num-writes)
          clear(writers)
          clear(var-side-effecting?)
          do(analyze, e)
        (e) :
          do(analyze, e)

    defn loop (e:ELItem) -> ELItem :
      match(e) :
        (e:ELocalFn) :
          println("\n--- WALKING LOCALFN %_---\n" % [n(e)]) when dtrace?
          map(loop, e)
        (e:EBody) :
          val body = rename-body(e, vt)
          sub-localfns(body, map(loop, localfns(e)) as Tuple<ELocalFn>)
        (e:EDefn|EDefmethod|EInit) :
          dtrace? = false ; n(e) == 8233
          println("\n--- WALKING DEFN %_---\n" % [n(e)]) when dtrace?
          val pe = remove-unreachable-code(e)
          analyze(pe)
          transitively-remove-unused-vars()
          analyze-freevars(map(loop, pe), vt)
        (e) :
          map(loop, e)

    loop(x) as ETExp

  within (texp, vt) = map-with-var-table(gvt, epackage, enabled?) :
    walk-top(texp, vt)


;============================================================
;================== Renaming ================================
;============================================================

defn rename-fn (f:EFn) -> EFn :
  ;Collect renamed identifiers
  val id-table = IntTable<Int>()
  val label-table = IntTable-init<Int>(uniqueid{})
  defn make-id (x:Int) : id-table[x] = uniqueid()
  defn make-ids (xs:Tuple<Int>) : do(make-id, xs)
  defn id (x:Int) : get?(id-table, x, x)
  defn ids (xs:Tuple<Int>) : map(id, xs)
  defn label* (x:Int) : label-table[x]

  ;Create new names for all local definitions
  defn create-definitions (e:ELItem) :
    match(e) :
      (e:EFn) :
        make-ids(targs(e))
        make-ids(args(e))
      (e:EBody) :
        do(make-id{n(_)}, locals(e))
        do(make-id{n(_)}, localtypes(e))
        do(make-id{n(_)}, localfns(e))
        do(make-id{n(_)}, localobjs(e))
      (e) :
        false
    do(create-definitions, e)

  ;Rename all references to local definitions
  defn rename (e:ELItem) :
    match(map(rename, e)) :
      ;Local definitions
      (e:EFn) : sub-args(sub-targs(e, ids(targs(e))), ids(args(e)))
      (e:ELocal) : sub-n(e, id(n(e)))
      (e:ELocalType) : sub-n(e, id(n(e)))
      (e:ELocalFn) : sub-n(e, id(n(e)))
      (e:ELocalObj) : sub-n(e, id(n(e)))
      ;Local usages - immediates
      (e:EMethod) : sub-thisn(e, id(thisn(e)))
      (e:EVar) : EVar(id(n(e)))
      (e:EVarLoc) : EVarLoc(id(n(e)))
      (e:ETVar): ETVar(id(n(e)))
      (e:ETVarLoc) : ETVarLoc(id(n(e)))
      ;Local usages - operations
      (e:ENew) : ENew(x(e), id(n(e)), info(e))
      ;Local usages - labels
      (e:ELabel) : ELabel(label*(n(e)))
      (e:EGoto)  : EGoto(label*(n(e)))
      (e:EIf) : EIf(label*(n1(e)), label*(n2(e)), op(e), ys(e))
      (e:EBranch) : EBranch(types(e), label*(n(e)), info(e))
      (e:ETypeof) : ETypeof(label*(n1(e)), label*(n2(e)), type(e), y(e))
      ;Fall through
      (e) : e

  create-definitions(f)
  rename(f) as EFn

;============================================================
;=================== Lambda Lifting =========================
;============================================================

deftype LiftTable
defmulti lift? (t:LiftTable, f:Int) -> True|False
defmulti get (t:LiftTable, f:Int) -> Free

defn LiftTable (etexp:ETExp, allow-global-closures?:True|False) :
  ;Populate freevar-table and value usage table
  val freevar-table = IntTable<Tuple<Int>>()
  val used-as-value = IntSet()
  val var-or-tvar = IntTable<True|False>()

  defn record-free (n:Int, f:Free) :
    freevar-table[n] = to-tuple(cat(vars(f), tvars(f)))
    for v in vars(f) do : var-or-tvar[v] = true
    for v in tvars(f) do : var-or-tvar[v] = false

  defn to-free (vs:Tuple<Int>) :
    val [vars, tvars] = split({var-or-tvar[_]}, vs)
    Free(to-tuple(vars), to-tuple(tvars))

  scan(etexp) where :
    defn scan (e:ELItem) :    
      match(e) :
        (e:ELocalFn) :
          record-free(n(e), fnfree(func(e)))
          do(scan, e)
        (e:EVar) : add(used-as-value, n(e))
        (e:ECall|ETCall) : do(scan, ys(e))
        (e) : do(scan, e)
    defn fnfree (f:EFunction) :
      match(f) :
        (f:EFn) : free(f)
        (f:EMultifn) : join-free $ seq(free, funcs(f))

  ;Compute lifting parameters
  ;Initially assume that all functions are lifted.
  val liftvar-table = let loop () :
    let :
      val num-lifted = length(freevar-table)
      identify-unlifted-functions()
      if length(freevar-table) < num-lifted :
        loop()
      else :
        val liftvars = compute-lift-vars()
        if length(freevar-table) < num-lifted : loop()
        else : liftvars
    where :
      defn forbid-lift? (f:Int, vars:Tuple<Int>) :
        defn unlifted? (n:Int) : not key?(freevar-table, n)
        val max-lift-vars = 8
        val num-free = count(unlifted?, vars)
        if allow-global-closures? :
          if num-free > 0 :
            used-as-value[f] or num-free > max-lift-vars
        else :
          used-as-value[f] or num-free > max-lift-vars

      defn identify-unlifted-functions () :
        for f in to-tuple(keys(freevar-table)) do :
          val free = freevar-table[f]
          remove(freevar-table,f) when forbid-lift?(f,free)

      defn compute-lift-vars () :
        to-inttable<Tuple<Int>> $
          for e in bipartite-closure(freevar-table) seq :
            val [f, free] = [key(e), value(e)]
            remove(freevar-table,f) when forbid-lift?(f,free)
            e

  ;Return table
  new LiftTable :
    defmethod lift? (this, f:Int) : key?(liftvar-table, f)
    defmethod get (this, f:Int) : to-free(liftvar-table[f])

defn lambda-lift (epackage:EPackage, gvt:VarTable) :
  ;Buffer for new top level expressions
  val new-texps = Vector<ETExp>()

  defn analyze (item:ETExp, lift-table:LiftTable, vt:VarTable) -> ETExp :
    ;Should the given local function be lifted?
    defn lifted? (e:ELocalFn) :
      lift?(lift-table, n(e))
    defn lifted? (e:EVarLoc) :
      lift?(lift-table, n(e))

    ;Return the free vars to lift e with, if e refers to a lifted function
    defn lift-free (e:EImm) -> Free|False :
      match(e) :
        (e:EVar) : lift-table[n(e)] when lift?(lift-table, n(e))
        (e:ECurry) : lift-table[n(x(e))] when lift?(lift-table, n(x(e)))
        (e) : false

    ;Add lifted type arguments to the given function immediate
    defn add-targs (e:EImm, free:Free) :
      defn curry (v:EVar, targs:Seq<EType>) :
        if empty?(targs) : v
        else : ECurry(v, to-tuple(targs))
      val free-targs = seq(ETVar, tvars(free))
      match(e) :
        (e:EVar) : curry(e, free-targs)
        (e:ECurry) : curry(x(e), cat(free-targs, targs(e)))

    ;Add lifted arguments to the given arguments
    defn add-args (xs:Tuple<EImm>, free:Free) :
      val vs = vars(free)
      if empty?(vs) : xs
      else : to-tuple(cat(seq(EVar, vs), xs))

    ;Lift a locally-defined function to the top-level
    defn lift-function (f:ELocalFn) -> False :
      ;Rename the free variables used in the func
      defn rename-free (func:EFn, free:Free) :
        if empty?(vars(free)) and empty?(tvars(free)) :
          func
        else :
          val rename-table = IntTable<Int>()
          for v in cat(vars(free), tvars(free)) do :
            rename-table[v] = uniqueid()
          rename-vars+tvars(func, rename-table)

      ;Lift all bodies in function
      defn lift-inner-functions (x:ELBigItem, free:Free) :
        match(x:EFn) :
          val targs* = to-tuple(cat(tvars(free), targs(x)))
          val args* = to-tuple(cat(vars(free), args(x)))
          val vartypes = seq(type{vt, _}, vars(free))
          val a1* = to-tuple(cat(vartypes, a1(x)))
          val body* = lift-bodies(body(x))
          val func* = EFn(tail?(x), targs*, args*, a1*, a2(x), body*, info(x))
          rename-free(func*, free)
        else :
          map(lift-inner-functions{_, free}, x)

      ;Driver
      val func* = lift-inner-functions(func(f), lift-table[n(f)])
      add(new-texps, EDefn(n(f), func* as EFunction, false))

    ;Process a body:
    ;  - Lift all local functions to top-level
    ;  - Transform instructions as necessary
    defn lift-bodies<?T> (x:?T&ELBigItem) -> T :
      match(x) :
        (body:EBody) :
          val buffer = BodyBuffer(body)
          for f in localfns(body) do :
            if lifted?(f) : lift-function(f)
            else : emit(buffer, lift-bodies(f))
          for o in localobjs(body) do :
            emit(buffer, lift-bodies(o))
          for ins in ins(body) do :
            match(ins) :
              (ins:ECall|ETCall) :
                fatal("Expected guards to be removed.") when calltype(ins) is CallGuarded
                match(lift-free(f(ins))) :
                  (free:Free) :
                    val f* = add-targs(f(ins), free)
                    val ys* = add-args(ys(ins), free)
                    emit(buffer, sub-f(sub-ys(ins, ys*), f*))
                  (_:False) :
                    emit(buffer, ins)
              (ins:EInitClosures) :
                val xs* = to-tuple(filter({not lifted?(_)}, xs(ins)))
                if not empty?(xs*) :
                  emit(buffer, EInitClosures(xs*, info(ins)))
              (ins) :
                emit(buffer, ins)
          to-body(buffer, true, false, false) as T&EBody
        (x) :
          map(lift-bodies, x)

    ;Driver: Recursively find all bodies and analyze them
    lift-bodies(item)

  ;Drive with local var table and free var analysis
  val epackage* = within (texp, vt) = map-with-var-table(gvt, epackage) :
    val texp* = analyze-freevars(texp,vt)
    val lift-table = LiftTable(texp*, false)
    analyze(texp*, lift-table, vt)
  add-exps(epackage*, new-texps)

;============================================================
;================== Basic Block Analysis ====================
;============================================================

deftype BasicBlockTable <: Collection<BBlock>
defmulti get (t:BasicBlockTable, lbl:Int) -> BBlock

deftype BBlock
defmulti lbl (b:BBlock) -> Int
defmulti index (b:BBlock) -> Int
defmulti successors (b:BBlock) -> Tuple<Int>
defmulti predecessors (b:BBlock) -> Tuple<Int>
defmulti instructions (b:BBlock) -> Seqable<EIns>

defn analyze-basic-blocks (ins:Tuple<EIns>) -> BasicBlockTable :
  defn sub-label (e:EIns, f:Int -> Int) :
    defn B (b:EBranch) : EBranch(types(b), f(n(b)), info(b))
    match(e) :
      (e:EIf) : EIf(f(n1(e)), f(n2(e)), op(e), ys(e))
      (e:EMatch|EDispatch) : sub-branches(e, map(B,branches(e)))
      (e:EGoto|ELabel) : fatal("Unreachable")
      (e) : e

  val bs = analyze-basic-blocks $ new Instructions :
    defmethod length (this) : length(ins)
    defmethod unique-label (this) : uniqueid()
    defmethod classify (this, i:Int) :
      match(ins[i]) :
        (ins:EIf) : JumpInstruction([n1(ins), n2(ins)])
        (ins:EMatch) : JumpInstruction(map(n,branches(ins)))
        (ins:EDispatch) : JumpInstruction(map(n,branches(ins)))
        (ins:EReturn) : JumpInstruction([])
        (ins:EEnd) : JumpInstruction([])
        (ins:ETCall) : JumpInstruction([])
        (ins:EGoto) : GotoInstruction(n(ins))
        (ins:ELabel) : LabelInstruction(n(ins))
        (ins) : StandardInstruction()

  defn BBlock (b:Block) :
    new BBlock :
      defmethod lbl (this) : n(b)
      defmethod index (this) : index(b)
      defmethod successors (this) : succs(b)
      defmethod predecessors (this) : preds(b)
      defmethod instructions (this) :
        for i in instructions(b) seq :
          match(i) :
            (i:Int) : sub-label(ins[i], renamed-label{bs, _})
            (ins:LabelInstruction) : ELabel(n(ins))
            (ins:GotoInstruction) : EGoto(n(ins))
  new BasicBlockTable :
    defmethod to-seq (this) : seq(BBlock, blocks(bs))
    defmethod get (this, lbl:Int) : BBlock(bs[lbl])

;============================================================
;=================== Type Annotation ========================
;============================================================
defn annotate-body-instructions (e:EBody, state0:Table<Int,EType>, vt:VarTable) -> Seqable<EIns> :
  ;Functions for retrieving the free variables in
  ;local functions and local objects.
  val localfn-table = to-inttable(n, localfns(e))
  val localobj-table = to-inttable(n, localobjs(e))
  defn all-free (fs:Seqable<EFunction>) :
    val free-vars = Vector<Int>()
    defn loop (fs:Seqable<EFunction>) :
      for f in fs do :
        match(f) :
          (f:EMultifn) : loop(funcs(f))
          (f:EFn) : add-all(free-vars, vars(free(f)))
    loop(fs)
    free-vars      
  defn local-fns-free (ns:Seqable<Int>) :
    all-free(seq(func{localfn-table[_]}, ns))
  defn local-obj-free (n:Int) :
    val ms = methods(localobj-table[n])
    all-free(seq(func, ms))

  ;Does the given instruction define a value?
  ;Returns false if it does not.
  ;Returns its identifier, and whether it is trusted if it does.
  defn definition? (i:EIns) -> False|[Int, True|False] :
    defn trusted (x:EVarLoc) : [n(x), true]
    defn untrusted (x:EVarLoc) : [n(x), false]
    match(i) :
      (i:ENew) : trusted(x(i))
      (i:ETuple) : trusted(x(i))
      (i:EVoidTuple) : trusted(x(i))
      (i:ETupleGet) : untrusted(x(i))
      (i:EObject) : trusted(x(i))
      (i:EObjectGet) : trusted(x(i))
      (i:EArray) : trusted(x(i))
      (i:EStruct) : trusted(x(i))
      (i:EPtr) : trusted(x(i))
      (i:ELoad) : untrusted(x(i))
      (i:EInterpret) : untrusted(x(i))
      (i:EConv) : untrusted(x(i))
      (i:EPrim) : trusted(x(i))
      (i:EBox) : trusted(x(i))
      (i:EBoxGet) : trusted(x(i))
      (i:EObjectGet) : trusted(x(i))
      (i:ECall) :
        match(x(i)) :
          (x:EVarLoc) :
            defn check-func (n:Int) :
              val arity = length(ys(i))
              if function?(vt,n) :
                if lostanza?(vt,n) : untrusted(x)
                else if tail?(vt,n,arity) : untrusted(x)
                else : trusted(x)
              else : untrusted(x)
            match(f(i)) :
              (f:EVar) : check-func(n(f))
              (f:ECurry) : check-func(n(/x(f)))
              (f:EImm) : untrusted(x)
          (_:False) :
            false
      (i) : false

  ;Create the input needed for type inference algorithm
  defn make-input () :
    new IInput :
      defmethod blocks (this) :
        seq(to-iblock, analyze-basic-blocks(ins(e)))
      defmethod entry-state (this, n:Int) :
        if key?(localfn-table, n) : EOf(/n(iotable(vt), CORE-FN-ID))
        else : state0[n]

  ;Is this variable a local, non-mutable, reftype variable?
  defn inferred-var? (n:Int) :
    not global?(vt, n) and
    not mutable?(vt, n) and
    reftype?(type(vt,n))
  defn inferred-var? (v:EImm) :
    match(v:EVar) : inferred-var?(n(v))

  ;Convert a EBlock into input needed for type inference algorithm
  defn to-iblock (b:BBlock) :
    new IBlock :
      defmethod n (this) :
        lbl(b)
      defmethod predecessors (this) :
        predecessors(b)
      defmethod instructions (this) :
        generate<IIns> :
          for instruction in instructions(b) do :
            ;Indicate usages
            match(instruction) :
              (i:EInitClosures) :
                for v in local-fns-free(seq(n, xs(i))) do :
                  yield(IUse(v)) when inferred-var?(v)
              (i:ENew) :
                for v in local-obj-free(n(i)) do :
                  yield(IUse(v)) when inferred-var?(v)
              (i:ECheck) :
                yield(IUse(n(y(i) as EVar))) when inferred-var?(y(i))
              (i) : false
              
            ;Add definitions
            match(definition?(instruction)) :
              ([n, trusted?]:[Int, True|False]) :
                if inferred-var?(n) :
                  val t* = type(vt,n) when trusted? else erase(type(vt,n))
                  yield(IDef(n, t*, instruction))
                else :
                  yield(IWrapped(instruction))
              (_:False) :
                match(instruction) :
                  (i:EDef) :
                    if inferred-var?(n(x(i))) :
                      if inferred-var?(y(i) as EImm) :
                        yield(IInherit(n(x(i)), n(y(i) as EVar), i))
                      else :
                        yield(IDef(n(x(i)), type(vt,y(i) as EImm), i))
                    else :
                      yield(IWrapped(i))
                  (i:ENewObject) :
                    yield(IDef(n(x(i)), EOf(n(i)), i))
                  (i:EMatch|EDispatch) :
                    yield(IMatch(i, inferred-var?))
                  (i:ECheck) :
                    if inferred-var?(y(i)) :
                      yield(ICast(n(y(i) as EVar), type(i), i))
                    else :
                      yield(IWrapped(i))
                  (i) :
                    yield(IWrapped(i))

  ;Run inference and produce new block
  defn run-inference (input:IInput) :
    for i in infer(input) seq? :
      match(i) :
        (i:IAnnotation) :
          One(EAnnotate(n(i), type(i)))
        (i) : 
          match(wrapped(i)) :
            (w:EIns) : One(w)
            (w:False) : None()            

  ;Driver
  run-inference(make-input())

defn annotate-function (e:EFn, parent-state:Table<Int,EType>, vt:VarTable) -> EFn :
  val state = IntTable<EType>()
  for (a in args(e), t in a1(e)) do :
    state[a] = t
  for v in vars(free(e)) do :
    if key?(parent-state,v) :
      state[v] = parent-state[v]
  val body* = annotate-body(body(e), state, vt)
  sub-body(e, body*)

defn annotate-body (b:EBody, state:Table<Int,EType>, vt:VarTable) -> EBody :
  val buffer = BodyBuffer(b)
  val localfn-table = to-inttable(n, localfns(b))
  val localobj-table = to-inttable(n, localobjs(b))
  defn annotate (f:EFunction) :
    match(f) :    
      (f:EFn) :
        annotate-function(f, state, vt)
      (f:EMultifn) :
        EMultifn $ for f in funcs(f) map :
          annotate-function(f, state, vt)
  defn analyze-function (n:Int) :
    val f = localfn-table[n]
    emit(buffer, sub-func(f, annotate(func(f))))
  defn analyze-obj (n:Int) :
    val o = localobj-table[n]
    val methods* = for m in methods(o) map :
      val func* = annotate-function(func(m), state, vt)
      sub-func(m, func*)
    emit(buffer, sub-methods(o, methods*))
    
  val ins* = annotate-body-instructions(b, state, vt)
  for i in ins* do :
    emit(buffer, i)
    match(i) :
      (i:EAnnotate) :
        state[n(i)] = type(i)
      (i:EInitClosures) :
        for x in xs(i) do :
          analyze-function(n(x))
      (i:ENew) :
        analyze-obj(n(i))
      (i) : false
  to-body(buffer, true, false, false)

defmulti wrapped (e:IIns) -> EIns|False
defmethod wrapped (e:IIns) : false

defn ICast (n:Int, type:EType, wrapped:EIns|False) :
  new ICast :
    defmethod n (this) : n
    defmethod type (this) : type
    defmethod wrapped (this) : wrapped
    defmethod print (o:OutputStream, this) : print(o, "cast %_ : %_" % [n, type])

defn IBranch (b:EBranch, ys:Tuple<EImm>, inferred-var?:EImm -> True|False) :
  val casts = to-tuple $ for (y in ys, t in types(b)) seq? :
    if inferred-var?(y) : One(ICast(n(y as EVar), t, false))
    else : None()    
  new infer-Branch :
    defmethod n (this) : n(b)
    defmethod casts (this) : casts

defn IMatch (i:EMatch|EDispatch, inferred-var?:EImm -> True|False) :
  val bs* = map(IBranch{_, ys(i), inferred-var?}, branches(i))
  new IMatch :
    defmethod branches (this) : bs*
    defmethod wrapped (this) : i
    defmethod print (o:OutputStream, this) : print(o, "match")

defn IUse (n:Int) :
  new IUse :
    defmethod n (this) : n
    defmethod print (o:OutputStream, this) : print(o, "use %_" % [n])

defn IDef (n:Int, t:EType, wrapped:EIns|False) :
  new IDef :
    defmethod n (this) : n
    defmethod type (this) : t
    defmethod wrapped (this) : wrapped
    defmethod print (o:OutputStream, this) : print(o, "def %_ : %_" % [n, t])

defn IInherit (n:Int, v:Int, wrapped:EIns|False) :
  new IInherit :
    defmethod n (this) : n
    defmethod inherit (this) : v
    defmethod wrapped (this) : wrapped    
    defmethod print (o:OutputStream, this) : print(o, "inherit %_ : %_" % [n, v])

defn IWrapped (i:EIns) :
  new IIns :
    defmethod wrapped (this) : i
    defmethod print (o:OutputStream, this) : print(o, "wrapped %_" % [i])

defstruct EAnnotate <: EIns :
  n: Int
  type: EType
defmethod print (o:OutputStream, e:EAnnotate) :
  print(o, "annotate V%_ : %_" % [n(e), type(e)])

;Erase type if reference type
;LoStanza types are trusted.
defn erase (t:EType) :
  ETop() when reftype?(t) else t

;Update types in body
defn update-local-types (e:EBody, vt:VarTable) -> EBody :
  ;Retrieve the trusted declared type of a variable
  defn var-type (v:Int, state:Table<Int,EType>, vt:VarTable) :
    if key?(state,v) :
      state[v]
    else :
      val t = type(vt,v)
      if lostanza?(vt,v) : erase(t)
      else : t

  val state = IntTable<EType>(ETop())
  val buffer = BodyBuffer(e)
  for i in ins(e) do :
    match(i:EAnnotate) :
      update(state, { EOr(type(i), _) }, n(i))
    else :
      emit(buffer, i)
  val locals = to-tuple $ for l in locals(e) seq :
    ELocal(n(l), normalize(var-type(n(l), state, vt)), mutable?(l))
  sub-locals(to-body(buffer), locals)

defn update-types (f:ETExp, vt:VarTable) :
  defn update-local-types-in-bodies (e:ELBigItem) :
    match(map(update-local-types-in-bodies, e)) :
      (e:EBody) : update-local-types(e, vt)
      (e) : e
  defn process (f:ELBigItem) :
    match(f) :
      (f:EDefn|EDefmethod|EInit) :
        println(">>> TYPING DEFN %_" % [n(f)]) flush(STANDARD-OUTPUT-STREAM as FileOutputStream)
        map(process, analyze-freevars(f, vt))
      (f:EFn) : update-local-types-in-bodies(annotate-function(f, IntTable<EType>(), vt))
      (f:EBody) : update-local-types-in-bodies(annotate-body(f, IntTable<EType>(), vt))
      (f) : map(process, f)
  process(f) as ETExp

defn update-type-annotations (epackage:EPackage, gvt:VarTable, enabled?:Int -> True|False) -> EPackage :
  map-with-var-table(update-types, gvt, epackage, enabled?)

;============================================================
;==================== Check Elision =========================
;============================================================
;defstruct TypeState :
;  n: Int
;  type: EType

defn elide-checks (epackage:EPackage, ehier:EHier, gvt:VarTable) -> EPackage :
  ;Elide all checks in body
  defn elide-checks (e:EBody, vt:VarTable) -> EBody :
    val buffer = BodyBuffer(e)
    val state = IntTable<EType>()
    for e in ins(e) do :
      match(e) :
        (e:EAnnotate) :
          state[n(e)] = type(e)
        (e:ECheck) :
          if not subtype?(ehier, imm-type(y(e), state, vt), type(e)) :
            emit(buffer, e)
        (e) :
          emit(buffer, e)
    to-body(buffer)

  ;Elide checks recursively in the given top level expression e
  defn elide-texp (e:ETExp, vt:VarTable) :    
    ;Elide checks in all bodies
    defn elide-checks-in-bodies (e:ELBigItem) :
      match(map(elide-checks-in-bodies, e)) :
        (e:EBody) : elide-checks(e, vt)
        (e) : e
    ;Annotate and process
    defn process (e:ELBigItem) :
      match(e) :
        (e:EFn) : elide-checks-in-bodies(annotate-function(e, IntTable<EType>(), vt))
        (e:EBody) : elide-checks-in-bodies(annotate-body(e, IntTable<EType>(), vt))
        (e) : map(process, e)
    ;Compute free variables and then process
    process(analyze-freevars(e,vt)) as ETExp

  ;Launch
  map-with-var-table(elide-texp, gvt, epackage)
  
;============================================================
;=================== Object Lifting =========================
;============================================================

defn lift-objects (epackage:EPackage, gvt:VarTable) -> EPackage :
  ;Buffer for new top level expressions
  val new-texps = Vector<ETExp>()

  ;Lift an instance method to the top level
  ;objfree contains the freevars stored in the object
  ;obj-n is the identifier of the EDefObject of the object declaration
  ;Returns the method id
  defn lift-method (obj-n:Int, m:EMethod, objfree:Free, vt:VarTable) -> Int :
    val fbody = body(func(m))
    val buffer = BodyBuffer(fbody)

    ;Track necessary renames
    val rename-table = IntTable<Int>()
    defn rename-var (v:Int) :
      val v* = uniqueid()
      rename-table[v] = v*
      v*

    ;Emit freevars for variables
    for v in vars(free(func(m))) do :
      val i = index-of(vars(objfree), v)
      match(i:Int) :
        val v* = rename-var(v)
        val t = type(vt, v)
        emit(buffer, ELocal(v*, t, false))
        emit(buffer, EObjectGet(EVarLoc(v*), EVar(thisn(m)), obj-n, i))
    ;Emit freetypes
    for v in tvars(free(func(m))) do :
      val i = index-of!(tvars(objfree), v)
      val v* = rename-var(v)
      emit(buffer, ELocalType(v*))
      emit(buffer, EObjectTGet(ETVarLoc(v*), EVar(thisn(m)), obj-n, i))

    ;Check that recursion has been done
    fatal("Objects not yet lifted!") when not empty?(localobjs(fbody))

    ;Emit renamed function and body
    for f in localfns(fbody) do :
      emit(buffer, rename-vars+tvars(f, rename-table))
    for i in ins(fbody) do :
      emit(buffer, rename-vars+tvars(i, rename-table))

    ;Push new method to top level
    val f = func(m)
    val a1* = to-tuple $
      for (x in args(f), t in a1(f)) seq :
        EOf(obj-n) when x == thisn(m) else remove-tvars(t)
    val a2* = remove-tvars(a2(f))
    val f* = EFn(tail?(f), targs(f), args(f), a1*, a2*, to-body(buffer, true, false, false), info(f))
    val method-id = uniqueid()
    add(new-texps, EDefmethod(method-id, multi(m), [], f*, false))
    method-id

  ;Sweep through the body and lift out declarations of local objects.
  defn lift-body (e:EBody, vt:VarTable) :
    ;For each object, which we will lift to obj-n:
    ;- calculate the freevars stored in the object
    ;- then generate the object declaration
    ;- then lift each instance method to the top level
    ;- then sweep through instructions and replace ENew with ENewObject

    ;Keep track of computed object freevars
    val objfree-table = IntTable<Free>()

    ;Lift each object
    for obj in localobjs(e) do :
      ;Compute object freevars
      val objfree = join-free(seq(free{func(_)}, methods(obj)))
      objfree-table[n(obj)] = objfree

      ;Lift instance methods
      val methods = map(lift-method{n(obj), _, objfree, vt}, methods(obj))

      ;Generate object declaration
      add(new-texps, EDefObject(n(obj), type(obj), ntargs, nargs, methods)) where :
        val ntargs = length(tvars(objfree))
        val nargs = length(vars(objfree))

    ;Generate new instructions
    val ins* = for i in ins(e) map :
      match(i:ENew) :
        val objfree = objfree-table[n(i)]
        val ys = map(EVar, vars(objfree))
        val targs = map(ETVar, tvars(objfree))
        ENewObject(x(i), n(i), targs, ys, info(i))
      else : i

    ;Return new body
    sub-localobjs{_, []} $
    sub-ins(e, ins*)

  ;Recursively analyze each body
  defn analyze (e:ELBigItem, vt:VarTable) -> ELBigItem :
    match(map(analyze{_, vt}, e)) :
      (e:EBody) : lift-body(e, vt)
      (e) : e

  val epackage* = within (texp, vt) = map-with-var-table(gvt, epackage) :
    val texp* = analyze-freevars(texp,vt)
    analyze(texp*, vt) as ETExp
  add-exps(epackage*, new-texps)

;============================================================
;=============== Building the Method Table ==================
;============================================================

;Create a class tree
defn make-class-tree (epackage:EPackage) -> DynTree :
  ;Retrieve all ids in type
  defn parent-ids (t:EType|False) :
    let loop (t:EType|False = t) :
      match(t) :
        (t:EAnd) : cat(loop(a(t)), loop(b(t)))
        (t:EOf) : [n(t)]
        (t:False) : []

  ;Create class tree
  DynTree $ for e in exps(epackage) seq? :
      match(e) :
        (e:EDefType) : One(NodeState(n(e), to-tuple(parent-ids(parent(e))), children(e), false))
        (e:EDefStruct) : One(NodeState(n(e), to-tuple(parent-ids(parent(e))), [], true))
        (e:EDefObject): One(NodeState(n(e), to-tuple(parent-ids(parent(e))), [], true))
        (e) : None()

deftype MethodTable
defmulti resolve-target (t:MethodTable, multi:Int, args:Tuple<EType>) -> Int|False
defmulti class-tree (t:MethodTable) -> DynTree

defn MethodTable (epackage:EPackage, class-tree:DynTree) :  
  ;Driver
  defn driver () :
    ;val class-tree = make-class-tree()
    val method-table = create-method-table()
    val dag-table = create-dag-table(class-tree, method-table)
    build-method-table(class-tree, dag-table)

  ;Create method table
  defn create-method-table () :
    val method-table = IntListTable<EDefmethod>()    
    for e in filter-by<EDefmethod>(exps(epackage)) do :
      add(method-table, multi(e), e)
    method-table

  ;Create a dispatch Dag
  defn create-dag (class-tree:DynTree, ms:Tuple<EDefmethod>) -> MethodDag :
    defn to-branch (m:EDefmethod) :
      val method-types = a1(func(m))
      val args* = map(etype-to-arg{class-tree, _, true}, method-types)
      Branch(args*)
    val branch-table = BranchTable(map(to-branch, ms), non-leaves(class-tree))
    val dag = compute-dispatch-dag(branch-table, true)
    MethodDag(dag, map(n,ms))

  ;Create multi dag table
  defn create-dag-table (class-tree:DynTree, method-table:IntListTable<EDefmethod>) :
    val dag-table = IntTable<MethodDag>()
    for entry in method-table do :
      dag-table[key(entry)] = create-dag(class-tree, to-tuple(value(entry)))
    dag-table

  ;Resolve through dag
  defn resolve-target (class-tree:DynTree, dag-table:IntTable<MethodDag>, multi:Int, types:Tuple<EType>) -> Int|False :
    val mdag = get?(dag-table, multi)
    match(mdag:MethodDag) :
      val args = map(etype-to-arg{class-tree, _, false}, types)
      val solns = all-solns(dag(mdag), args, false)
      ; println("FOUND %_ -> %_ / %_" % [args, solns, targets(mdag)])
      if length(solns) == 1 :
        val i = index(solns[0] as UniqueSoln)
        targets(mdag)[i]
      ; else :
      ;   println("AMBIGUOUS %_" % [mdag])

  ;Build the Method Table
  defn build-method-table (class-tree:DynTree, dag-table:IntTable<MethodDag>) :
    new MethodTable :
      defmethod class-tree (this) : class-tree
      defmethod resolve-target (this, multi:Int, args:Tuple<EType>) :
        resolve-target(class-tree, dag-table, multi, args)
        
  ;Launch
  driver()

;Retrieve the trusted declared type of a variable
defn var-type (v:Int, state:Table<Int,EType>, vt:VarTable) :
  if key?(state,v) :
    state[v]
  else :
    val t = type(vt,v)
    if lostanza?(vt,v) : erase(t)
    else : t

;Retrieve the type of the given immediate
defn imm-type (x:EImm, state:Table<Int,EType>, vt:VarTable) :
  match(x:EVar) : var-type(n(x), state, vt)
  else : type(vt, x)

defn resolve-methods (epackage:EPackage, gvt:VarTable, method-table:MethodTable, enabled?: Int -> True|False, changed?:IntSet) -> EPackage :
  defn resolve-in-body (e:EBody, vt:VarTable, top:False|Int) -> EBody :
    val buffer = BodyBuffer(e)
    val state = IntTable<EType>()
    for i in ins(e) do :
      ;Resolve target of call
      defn resolve-call (f:EImm, ys:Tuple<EImm>) -> EImm|False :
        val fid = match(f) :
          (f:EVar) : n(f)
          (f:ECurry) : n(x(f))
          (f) : false
        defn sub-fid (n:Int) :
          match(f) :
            (f:EVar) : EVar(n)
            (f:ECurry) : ECurry(EVar(n), targs(f))
        match(fid:Int) :
          val ys-types = map(type{vt, _}, ys)
          ; print("RESOLVING %_%_ " % [fid, ys-types])
          match(resolve-target(method-table, fid, ys-types)) :
            (n:Int) :
              match(top:Int) : (add(changed?, top)) ; println("RESOLVING %_%_ -> %_" % [fid, ys-types, n])
              sub-fid(n)
            (n:False) :
              false 
            
      ;Resolve calls and tcalls
      match(i:EAnnotate) :
        state[n(i)] = type(i)
      else :
        val ni = match(i) :
          (i:ECall|ETCall) :
            val f* = resolve-call(f(i), ys(i))
            match(f*:EImm) : sub-f(i, f*) else : i
          (i:EMatch) :
            defn to-args (types:Tuple<EType>) -> Tuple<Arg> :
              map(etype-to-arg{class-tree(method-table), _, false}, types)
            val ys-types = map(imm-type{_, state, vt}, ys(i))
            val args = to-args $ ys-types
            val eligible-branches = to-tuple $ for b in branches(i) filter :
              all?(overlap?, args, to-args $ types(b))
            if length(eligible-branches) == length(branches(i)) :
              i
            else :
              match(top:Int): add(changed?, top)
              ; println("OPT MATCH DEFN %_" % [top])
              ; println(i)
              ; println("YS-TYPES %_" % [ys-types])
              ; println("ELIGIBLE BRANCHES %_" % [eligible-branches])
              if empty?(eligible-branches) :
                ; println("NONE")
                sub-branches(i, [])
              else if all?(subarg?, args, to-args $ types(eligible-branches[0])) :
                ; println("GOTO [0]")
                EGoto(n(eligible-branches[0]))
              else :
                ; println("PRUNE")
                sub-branches(i, eligible-branches)
          (i) : i
        emit(buffer, ni)

    ; match(top:Int) :
    ;   if changed?[top] :
    ;     println("---BEFORE: ")
    ;     for i in ins(e) do : println(i)
    ;     println("---DONE BEFORE ")
    to-body(buffer)

  defn resolve-texp (x:ETExp, vt:VarTable) :
    val top = match(x:EDefmethod|EDefn|EInit) : n(x)

    ;Elide checks in all bodies
    defn resolve-methods-in-bodies (e:ELBigItem) :
      match(map(resolve-methods-in-bodies, e)) :
        (e:EBody) : resolve-in-body(e, vt, top)
        (e) : e

    ;Annotate and process
    defn process (e:ELBigItem) :
      match(e) :
        (e:EFn) : resolve-methods-in-bodies(annotate-function(e, IntTable<EType>(), vt))
        (e:EBody) : resolve-methods-in-bodies(annotate-body(e, IntTable<EType>(), vt))
        (e) : map(process, e)
    ;Compute free variables and then process
    process(analyze-freevars(x,vt)) as ETExp

  ;println("=== RESOLVING-METHODS")
  map-with-var-table(resolve-texp, gvt, epackage, enabled?)

; defn resolve-methods (epackage:EPackage, gvt:VarTable, method-table:MethodTable, enabled?: Int -> True|False, changed?:IntSet) -> EPackage :
;   defn resolve-in-body (e:EBody, vt:VarTable, top:False|Int) -> EBody :
;     val ins* = for i in ins(e) map :
;       ;Resolve target of call
;       defn resolve-call (f:EImm, ys:Tuple<EImm>) -> EImm|False :
;         val fid = match(f) :
;           (f:EVar) : n(f)
;           (f:ECurry) : n(x(f))
;           (f) : false
;         defn sub-fid (n:Int) :
;           match(f) :
;             (f:EVar) : EVar(n)
;             (f:ECurry) : ECurry(EVar(n), targs(f))
;         match(fid:Int) :
;           val ys-types = map(type{vt, _}, ys)
;           ; print("RESOLVING %_%_ " % [fid, ys-types])
;           match(resolve-target(method-table, fid, ys-types)) :
;             (n:Int) :
;               match(top:Int) : (add(changed?, top)) ; println("RESOLVING %_%_ -> %_" % [fid, ys-types, n])
;               sub-fid(n)
;             (n:False) :
;               false 
;             
;       ;Resolve calls and tcalls
;       match(i) :
;         (i:ECall|ETCall) :
;           val f* = resolve-call(f(i), ys(i))
;           match(f*:EImm) : sub-f(i, f*)
;           else : i
;         (i) : i
;     sub-ins(e, ins*)
;   defn resolve-texp (x:ETExp, vt:VarTable) :
;     val top = match(x:EDefmethod|EDefn|EInit) : n(x)
;     val result = let loop (x:ELBigItem = x) :
;       match(map(loop, x)) :
;         (e:EBody) : resolve-in-body(e,vt,top)
;         (e) : e
;     result as ETExp
;   ;println("=== RESOLVING-METHODS")
;   map-with-var-table(resolve-texp, gvt, epackage, enabled?)

defstruct MethodDag :
  dag: Dag
  targets: Tuple<Int>
with:
  printer => true

;============================================================
;===================== SPECIALIZE ===========================
;============================================================

defn specialize (epackage:EPackage, gvt:VarTable, enabled?:Int -> True|False, changed?:IntSet,
                 fun-variants:IntTable<HashTable<Tuple<EType>,Int>>, new-specializations:IntSet, specialized-parents:IntTable<Int>) -> EPackage :

  val fns = to-inttable<EDefn|EDefmethod> $ generate<KeyValue<Int,EDefn|EDefmethod>> :
    for e in filter-by<EDefn|EDefmethod>(exps(epackage)) do :
      yield(n(e) => e) when func(e) is EFn

  val new-variants = Vector<ETExp>()

  defn spec-in-body (e:EBody, vt:VarTable,top:False|Int) -> EBody :
    val buffer = BodyBuffer(e)
    val state = IntTable<EType>()
    for i in ins(e) do :
      ;Resolve target of call
      defn spec-call (f:EImm, ys:Tuple<EImm>) -> EImm|False :
        val fid = match(f) :
          (f:EVar) : n(f)
          (f:ECurry) : n(x(f))
          (f) : false
        defn sub-fid (n:Int) :
          match(f) :
            (f:EVar) : EVar(n)
            (f:ECurry) : ECurry(EVar(n), targs(f))
        match(fid:Int) :
          val variants = get?(fun-variants, fid)
          match(variants:HashTable<Tuple<EType>,Int>) :
            val ys-types = map(type{vt, _}, ys)
            match(get?(variants, ys-types)) :
              (f:False) :
                val nfid = uniqueid()
                val et = fns[fid]
                val ef = func(et) as EFn
                val copy = EDefn(nfid, rename-fn(sub-a1(ef, ys-types)), lostanza?(et))
                specialized-parents[nfid] = fid
                add(new-specializations, nfid)
                add(new-variants, copy)
                add(changed?, nfid)
                variants[ys-types] = nfid
                ; println("  CREATING NEW %_ %_ PARENT %_" % [nfid, ys-types, fid]) flush(STANDARD-OUTPUT-STREAM as FileOutputStream)
                sub-fid(nfid)
              (f:Int) :
                ; println("  LOOKING UP FID %_ VS F %_" % [fid, f])
                sub-fid(f) when (f != fid)
            
      ;Resolve calls and tcalls
      match(i) :
        (i:EAnnotate) :
          state[n(i)] = type(i)
        (i:ECall|ETCall) :
          val f* = spec-call(f(i), ys(i))
          val ni = match(f*:EImm) : ((match(top:Int) : add(changed?, top)), sub-f(i, f*))
                   else : i
          emit(buffer, ni)
        (i) :
          emit(buffer, i)

    to-body(buffer)

  defn resolve-texp (x:ETExp, vt:VarTable) :
    val top = match(x:EDefmethod|EDefn|EInit) :
      ; println("SPECING %_" % [n(x)]) flush(STANDARD-OUTPUT-STREAM as FileOutputStream)
      n(x)

    defn spec-in-bodies (x:ELBigItem) :
      match(map(spec-in-bodies, x)) :
        (e:EBody) : spec-in-body(e,vt,top)
        (e) : e

    ;Annotate and process
    defn process (e:ELBigItem) :
      match(e) :
        (e:EFn) : spec-in-bodies(annotate-function(e, IntTable<EType>(), vt))
        (e:EBody) : spec-in-bodies(annotate-body(e, IntTable<EType>(), vt))
        (e) : map(process, e)

    process(analyze-freevars(x, vt)) as ETExp

  val res0 = map-with-var-table(resolve-texp, gvt, epackage, enabled?)
  println("ADDING %_ VARIANTS" % [length(new-variants)])
  sub-exps(res0, to-tuple $ cat(exps(res0), new-variants))

;defn kv<?K,?V> (entry:KeyValue<?K,?V>) -> [K,V] :
;   [key(entry), value(entry)]

defn kv<?K,?V> (entries:Seqable<KeyValue<?K,?V>>) -> Seqable<[K,V]> :
  for e in entries seq : [key(e), value(e)]

defn despecialize (epackage:EPackage, gvt:VarTable, enabled?:Int -> True|False, 
                   fun-variants:IntTable<HashTable<Tuple<EType>,Int>>, new-specializations:IntSet, specialized-parents:IntTable<Int>) -> EPackage :

  val new-defns = Vector<EDefn|EDefmethod>()
  val defns = to-inttable<EDefn|EDefmethod> $ generate<KeyValue<Int,EDefn|EDefmethod>> :
    for e in filter-by<EDefn|EDefmethod>(exps(epackage)) do :
      match(func(e)) :
        (f:EFn) :
          yield(n(e) => e)
          add(new-defns, e) when new-specializations[n(e)]
        (f) : false

  val despec-defns = IntSet()

  defn num-instructions (e:ETExp) -> Int :
    var num:Int = 0
    let loop (x:ELBigItem = e) :
      match(map(loop, x)) :
        (e:EBody) : (num = num + length(ins(e)), e)
        (e) : e
    num

  ;TODO: STRENGTHEN THIS
  defn improved? (e0:EDefn|EDefmethod, e1:EDefn|EDefmethod) -> True|False :
    num-instructions(e0) != num-instructions(e1)

  for deffun in new-defns do :
    val parent-defn = defns[specialized-parents[n(deffun)]]
    add(despec-defns, n(deffun)) when not (n(parent-defn) == n(deffun) or improved?(parent-defn, deffun))

  defn despec (e:EBody, vt:VarTable) -> EBody :
    val ins* = for i in ins(e) map :
      ;Resolve target of call
      defn despec-call (f:EImm, ys:Tuple<EImm>) -> EImm|False :
        val fid = match(f) :
          (f:EVar) : n(f)
          (f:ECurry) : n(x(f))
          (f) : false
        defn sub-fid (n:Int) :
          match(f) :
            (f:EVar) : EVar(n)
            (f:ECurry) : ECurry(EVar(n), targs(f))
        match(fid:Int) :
          if despec-defns[fid] :
            val pfid = specialized-parents[fid]
            val variants = fun-variants[pfid]
            val fun = func(defns[fid]) as EFn
            variants[a1(fun)] = pfid
            ;println("REPLACING VARIANT ON %_ FROM %_ TO %_" % [a1(fun), fid, pfid])
            sub-fid(pfid)
            
      ;Despecialize calls and tcalls
      match(i) :
        (i:ECall|ETCall) :
          val f* = despec-call(f(i), ys(i))
          match(f*:EImm) : sub-f(i, f*)
          else : i
        (i) : i
    sub-ins(e, ins*)

  defn resolve-texp (x:ETExp, vt:VarTable) :
    ; match(x:EDefmethod|EDefn) : println("DESPECING %_" % [n(x)])
    val result = let loop (x:ELBigItem = x) :
      match(map(loop, x)) :
        (e:EBody) : despec(e,vt)
        (e) :       e
    result as ETExp

  val res0 = map-with-var-table(resolve-texp, gvt, epackage, enabled?)
  println("REMOVING %_ VARIANTS" % [length(despec-defns)])
  ; for spec in despec-defns do : println("DEL %_" % [spec])
  ;If specialized variants marked for removal might not be found in code because inlined already
  ;make sure to remove them from variant table so they don't reappear
  for [pfid, variants] in kv(fun-variants) do :
    for [types,fid] in kv(variants) do :
      if despec-defns[fid] :
        ;println("FOUND DESPEC %_ IN %_ VARIANT %_" % [fid, pfid, types])
        variants[types] = pfid
  val new-exps = to-tuple $ for e in exps(res0) filter :
    not match(e:EDefn|EDefmethod) : despec-defns[n(e)]
  sub-exps(res0, new-exps)

;============================================================
;===================== SHRINK IFS ===========================
;============================================================

defstruct InsRewrite :
  off : Int
  new-ins : EIns
with:
  printer => true

;x is a small immediate if it can fit as an x86 immediate operand.
defn small-immediate? (x:EImm) :
  val max = 1 << 16
  val min = -1 << 16
  defn small? (v:Int) : v >= min and v <= max
  defn small? (v:Long) : v >= to-long(min) and v <= to-long(max)
  match(x) :
    (x:ELSLiteral) :
      match(value(x)) :
        (x:Byte) : true
        (x:Int|Long) : small?(x)
        (x) : false
    (x:EVar) : true
    (x:ETagof) : true
    (x) : false

defn match-x<?T> (return:() -> Void, inz:Seq<[Int,EIns]>, check:EIns -> False|?T) -> [Int,T] :
  return() when empty?(inz)
  val [off, ins] = peek(inz)
  match(check(ins)) :
    (ins:False) : return()
    (ins:T)     : (next(inz), [off, ins])

defn match-cmp-op (return:() -> Void, inz:Seq<[Int,EIns]>) -> [Int,EPrim] :
  defn check (ins:EIns) :
    match(ins:EPrim) : ins when op(ins) is EqOp|NeOp|LtOp|GtOp|LeOp|GeOp|UleOp|UltOp|UgtOp|UgeOp|IntLtOp|IntGtOp|IntLeOp|IntGeOp
  match-x(return, inz, check)

defn match-if (return:() -> Void, inz:Seq<[Int,EIns]>) -> [Int, EIf] :
  match-x(return, inz, fn (ins:EIns) : match(ins:EIf) : ins when op(ins) is False)

defn match-label (return:() -> Void, inz:Seq<[Int,EIns]>, target:Int) :
  match-x(return, inz, fn (ins) : match(ins:ELabel) : (n(ins) == target, ins))

defn maybe-match-live (inz:Seq<[Int,EIns]>) :
  if not empty?(inz) :
    val ins = peek(inz)[1]
    match(ins:ELive) : next(inz)

defn match-def (return:() -> Void, inz:Seq<[Int,EIns]>, var-loc:False|EVarLoc, target:ELSLiteral) -> [Int, EDef] :
  defn check (ins:EIns) :
    match(ins:EDef) :
      val t = y(ins)
      match(t:ELSLiteral) :
        if value(target) == value(t) :
          match(var-loc) :
            (var-loc:EVarLoc) : ins when n(x(ins)) == n(var-loc)
            (other) :           ins
  match-x(return, inz, check)

defn match-goto (return:() -> Void, inz:Seq<[Int,EIns]>, target:False|Int) -> [Int, EGoto] :
  defn check (ins:EIns) :
    match(ins:EGoto) :
      match(target) :
        (target:Int) : ins when n(ins) == target
        (target) :     ins
  match-x(return, inz, check)

defn match-match (return:() -> Void, vt:VarTable, inz:Seq<[Int,EIns]>, arg:Int) -> [Int,EMatch] :
  defn check (ins:EIns) :
    match(ins:EMatch) :
      if length(ys(ins)) == 1 and length(branches(ins)) == 2 :
        match(ys(ins)[0], types(branches(ins)[0])[0], types(branches(ins)[1])[0]) :
          (v:EVar, bt0:EOf, bt1:EOf) : ins when (n(v) == arg and n(bt0) == n(iotable(vt), CORE-TRUE-ID) and n(bt1) == n(iotable(vt), CORE-FALSE-ID))
          (y, bt0, bt1) : false
  match-x(return, inz, check)

defn trace-if (inz:Seq<[Int,EIns]>, i:Int) :
  ;; if not empty?(inz) :
  ;;   println("MATCHED %_: %_" % [i, peek(inz)])
  false

defn match-if-match (inz:Seq<[Int,EIns]>, vt:VarTable) -> Maybe<InsRewrite> :
  label<Maybe<InsRewrite>> top-return:
    defn return () : top-return(None())
    val [cmp-off, cmp-ins] = match-cmp-op(return, inz)
    trace-if(inz, 0)
    defn maybe-match-int-if () :
      if op(cmp-ins) is EqOp|NeOp|IntLtOp|IntGtOp|IntLeOp|IntGeOp :
        maybe-match-live(inz)
        trace-if(inz, 31)
        val [match-off, match-ins] = match-match(return, vt, inz, n(x(cmp-ins)))
        trace-if(inz, 32)
        val op =
          match(op(cmp-ins)) :
            (op:EqOp) : EqOp()
            (op:NeOp) : NeOp()
            (op:IntLtOp) : LtOp()
            (op:IntLtOp) : LtOp()
            (op:IntGtOp) : GtOp()
            (op:IntLeOp) : LeOp()
            (op:IntGeOp) : GeOp()
        top-return(One(InsRewrite(match-off, EIf(n(branches(match-ins)[0]), n(branches(match-ins)[1]), op, ys(cmp-ins)))))
      else :
        top-return(None())
    val [if-off, if-ins] = match-if(maybe-match-int-if, inz)
    trace-if(inz, 1)
    defn maybe-match-raw-if () :
      if op(cmp-ins) is EqOp|NeOp|LtOp|GtOp|LeOp|GeOp|UleOp|UltOp|UgtOp|UgeOp and all?(small-immediate?, ys(cmp-ins)):
        trace-if(inz, 21)
        top-return(One(InsRewrite(if-off, EIf(n1(if-ins), n2(if-ins), op(cmp-ins), ys(cmp-ins)))))
      else :
        top-return(None())
    match-label(maybe-match-raw-if, inz, n2(if-ins))
    trace-if(inz, 2)
    maybe-match-live(inz)
    trace-if(inz, 3)
    val [merge-off, merge-ins] = match-def(maybe-match-raw-if, inz, false, ELSLiteral(false))
    val merge-var = x(merge-ins)
    trace-if(inz, 4)
    val [goto-off, goto-ins] = match-goto(return, inz, false)
    val merge-label = n(goto-ins)
    trace-if(inz, 5)
    match-label(return, inz, n1(if-ins))
    trace-if(inz, 6)
    maybe-match-live(inz)
    trace-if(inz, 7)
    match-def(return, inz, merge-var, ELSLiteral(true))
    trace-if(inz, 8)
    match-goto(return, inz, merge-label)
    trace-if(inz, 9)
    match-label(return, inz, merge-label)
    trace-if(inz, 10)
    val [match-off, match-ins] = match-match(return, vt, inz, n(merge-var))
    trace-if(inz, 11)
    if all?(small-immediate?, ys(cmp-ins)) :
      One(InsRewrite(if-off, EIf(n(branches(match-ins)[0]), n(branches(match-ins)[1]), op(cmp-ins), ys(cmp-ins))))
    else :
      One(InsRewrite(if-off, EIf(n(branches(match-ins)[0]), n(branches(match-ins)[1]), false, ys(if-ins))))

defn shrink-ifs (epackage:EPackage, gvt:VarTable, enabled?: Int -> True|False, changed?:IntSet) -> EPackage :
  defn fold-in-body (e:EBody, top:False|Int, vt:VarTable) -> EBody :
    ;; println("--- BEFORE ---")
    ;; for (ins in ins(e), i in 0 to false) do: println("%_: %_" % [i, ins])
    val inz = zip(0 to false, ins(e))
    val rewrites = Queue<InsRewrite>()
    let loop (prev-idx:Int = 0) :
      match(match-if-match(inz, vt)) :
        (ir:One<InsRewrite>) :
          add(rewrites, value(ir))
          println("--- FOUND IF %_" % [value(ir)]) when trace-constant-folding?
        (none) : false
      if not empty?(inz) :
        val [now-idx, now-ins] = peek(inz)
        val nxt-idx = if now-idx == prev-idx: (next(inz), now-idx + 1)
                      else : now-idx
        loop(nxt-idx)
    if empty?(rewrites) :
      e
    else :
      ;; if not empty?(rewrites): for ins in ins(e) do : println(ins)
      val new-ins = to-tuple $ for (ins in ins(e), j in 0 to false) seq :
        if empty?(rewrites) :
          ins
        else :
          val rewrite = peek(rewrites)
          if j == off(rewrite) :
            add(changed?, top as Int) when top is Int
            (pop(rewrites), new-ins(rewrite)) ;; println("REWRITING %_: %_" % [j, new-ins(rewrite)])
          else :
            ins
      sub-ins(e, new-ins)
  defn resolve-texp (x:ETExp, vt:VarTable) :
    val top = match(x:EDefmethod|EDefn|EInit) : n(x)
    val result = let loop (x:ELBigItem = x) :
      match(map(loop, x)) :
        (e:EBody) : fold-in-body(e,top,vt)
        (e) : e
    result as ETExp
  map-with-var-table(resolve-texp, gvt, epackage, enabled?)

;============================================================
;==================== CONSTANT FOLD =========================
;============================================================
defn walk-writes (e:EBody, num-writes:IntTable) :
  defn walk-writes (e:ELItem, writer:False|EIns) :
    match(e) :
      (e:EVarLoc) :
        match(writer) :
          (writer:EIns) : inc(num-writes, n(e))
          (writer) :      false
      (e:EPtr|ELoad) :
        walk-writes(loc(e), false)
        walk-writes(x(e),   e)
      (e:EIns) :
        do(walk-writes{_, e}, e)
      (e) :
        do(walk-writes{_, false}, e)
  for i in ins(e) do : walk-writes(i, false)

defn disjoint? (ehier:EHier, t1:EType, t2:EType) -> True|False :
  not (subtype?(ehier, t1, t2) or subtype?(ehier, t2, t1))

val trace-constant-folding? = false

defmulti hi-partial-fold-binary-op (op:EOp, f:? -> EIns, a0:?, a1:?) -> False|EIns
  
defmethod hi-partial-fold-binary-op (op:EOp, f:? -> EIns, a0:?, a1:?) : false

defmethod hi-partial-fold-binary-op (op:IntAddOp|IntOrOp, f:? -> EIns, a0:?, a1:?) :
  match(a0, a1) :
    (a0:Int, a1) : f(a1) when (a0 == 0)
    (a0, a1:Int) : f(a0) when (a1 == 0)
    (a0, a1) :     false

defmethod hi-partial-fold-binary-op (op:IntSubOp, f:? -> EIns, a0:?, a1:?) :
  match(a1:Int): f(a0) when (a1 == 0)

defmethod hi-partial-fold-binary-op (op:IntMulOp, f:? -> EIns, a0:?, a1:?) :              
  match(a0, a1) :
    (a0:Int, a1) : f(a1) when (a0 == 1)
    (a0, a1:Int) : f(a0) when (a1 == 1)
    (a0, a1) :     false

defmethod hi-partial-fold-binary-op (op:IntAndOp, f:? -> EIns, a0:?, a1:?) :
  match(a0:Int, a1:Int) : f(0)  when (a0 == 0 or a1 == 0)

defmethod hi-partial-fold-binary-op (op:IntDivOp|IntModOp, f:? -> EIns, a0:?, a1:?) :
  match(a1:Int) : f(a0) when (a1 == 1)

defmethod hi-partial-fold-binary-op (op:IntShlOp|IntShrOp|IntAshrOp, f:? -> EIns, a0:?, a1:?) :
  match(a1:Int) : f(a0) when (a1 == 0)

defmulti hi-fold-binary-op (op:EOp, f:? -> EIns, a0:?, a1:?) -> False|EIns

defmethod hi-fold-binary-op (op:EOp, f:? -> EIns, a0:?, a1:?) :
  hi-partial-fold-binary-op(op, f, a0, a1)

defmethod hi-fold-binary-op (op:IntAddOp,  f:? -> EIns, a0:Int, a1:Int) : f(a0 + a1)
defmethod hi-fold-binary-op (op:IntSubOp,  f:? -> EIns, a0:Int, a1:Int) : f(a0 - a1)
defmethod hi-fold-binary-op (op:IntMulOp,  f:? -> EIns, a0:Int, a1:Int) : f(a0 * a1)
defmethod hi-fold-binary-op (op:IntDivOp,  f:? -> EIns, a0:Int, a1:Int) : f(a0 / a1)
defmethod hi-fold-binary-op (op:IntModOp,  f:? -> EIns, a0:Int, a1:Int) : f(a0 % a1)
defmethod hi-fold-binary-op (op:IntAndOp,  f:? -> EIns, a0:Int, a1:Int) : f(a0 & a1)
defmethod hi-fold-binary-op (op:IntOrOp,   f:? -> EIns, a0:Int, a1:Int) : f(a0 | a1)
defmethod hi-fold-binary-op (op:IntXorOp,  f:? -> EIns, a0:Int, a1:Int) : f(a0 ^ a1)
defmethod hi-fold-binary-op (op:IntShlOp,  f:? -> EIns, a0:Int, a1:Int) : f(a0 << a1)
defmethod hi-fold-binary-op (op:IntShrOp,  f:? -> EIns, a0:Int, a1:Int) : f(a0 >> a1)
defmethod hi-fold-binary-op (op:IntAshrOp, f:? -> EIns, a0:Int, a1:Int) : f(a0 >>> a1)
defmethod hi-fold-binary-op (op:IntLtOp,   f:? -> EIns, a0:Int, a1:Int) : f(a0 < a1)
defmethod hi-fold-binary-op (op:IntGtOp,   f:? -> EIns, a0:Int, a1:Int) : f(a0 > a1)
defmethod hi-fold-binary-op (op:IntLeOp,   f:? -> EIns, a0:Int, a1:Int) : f(a0 <= a1)
defmethod hi-fold-binary-op (op:IntGeOp,   f:? -> EIns, a0:Int, a1:Int) : f(a0 >= a1)
defmethod hi-fold-binary-op (op:LtOp,      f:? -> EIns, a0:Int, a1:Int) : f(a0 < a1)
defmethod hi-fold-binary-op (op:GtOp,      f:? -> EIns, a0:Int, a1:Int) : f(a0 > a1)
defmethod hi-fold-binary-op (op:LeOp,      f:? -> EIns, a0:Int, a1:Int) : f(a0 <= a1)
defmethod hi-fold-binary-op (op:GeOp,      f:? -> EIns, a0:Int, a1:Int) : f(a0 >= a1)
defmethod hi-fold-binary-op (op:EqOp,      f:? -> EIns, a0:Int, a1:Int) : f(a0 == a1)
defmethod hi-fold-binary-op (op:NeOp,      f:? -> EIns, a0:Int, a1:Int) : f(a0 != a1)

defmulti lo-fold-binary-op (op:EOp, f:? -> EIns, a0:?, a1:?) -> False|EIns

defmethod lo-fold-binary-op (op:EOp, f:? -> EIns, a0:?, a1:?) : false

defmulti lo-partial-fold-binary-op (op:EOp, f:? -> EIns, a0:?, a1:?) -> False|EIns

defmethod lo-partial-fold-binary-op (op:EOp, f:? -> EIns, a0:?, a1:?) : false

#for (Prim in [Byte Int Long],
      zero in [0Y, 0, 0L],
      one  in [1Y, 1, 1L]) :

  defmethod lo-fold-binary-op (op:ModOp,     f:? -> EIns, a0:Prim, a1:Prim) :        f(a0 % a1)
  defmethod lo-fold-binary-op (op:AndOp,     f:? -> EIns, a0:Prim, a1:Prim) :        f(a0 & a1)
  defmethod lo-fold-binary-op (op:OrOp,      f:? -> EIns, a0:Prim, a1:Prim) :        f(a0 | a1)
  defmethod lo-fold-binary-op (op:XorOp,     f:? -> EIns, a0:Prim, a1:Prim) :        f(a0 ^ a1)
  defmethod lo-fold-binary-op (op:ShlOp,     f:? -> EIns, a0:Prim, a1:Prim) :        f(a0 << a1)
  defmethod lo-fold-binary-op (op:ShrOp,     f:? -> EIns, a0:Prim, a1:Prim) :        f(a0 >> a1)
  defmethod lo-partial-fold-binary-op (op:DivOp|ModOp, f:? -> EIns, a0:?, a1:Prim) : match(a1:Prim) : f(a0) when (a1 == one)
  defmethod lo-partial-fold-binary-op (op:ShlOp|ShrOp, f:? -> EIns, a0:?, a1:Prim) : match(a1:Prim) : f(a0) when (a1 == zero)

defmethod lo-partial-fold-binary-op (op:AndOp, f:? -> EIns, a0:?, a1:?) :
  label<False|EIns> return :
    #for (Prim in [Byte, Int, Long],
          zero in [0Y,   0,   0L]) :
      match(a0:Prim) : if a0 == zero : return(f(zero))
      match(a1:Prim) : if a1 == zero : return(f(zero))

defmethod lo-partial-fold-binary-op (op:OrOp, f:? -> EIns, a0:?, a1:?) :
  label<False|EIns> return :
    #for (Prim in [Byte, Int, Long],
          zero in [0Y,   0,   0L]) :
      match(a0:Prim) : if a0 == zero: return(f(a1))
      match(a1:Prim) : if a1 == zero: return(f(a0))

#for (Prim in [Int Long]) :
  defmethod lo-fold-binary-op (op:AshrOp,    f:? -> EIns, a0:Prim, a1:Prim) : f(a0 >>> a1)

defmethod lo-partial-fold-binary-op (op:ShlOp|ShrOp, f:? -> EIns, a0:?, a1:?) : 
  label<False|EIns> return :
    #for (Prim in [Int, Long],
          one  in [1,   1L]) :
      match(a1:Prim) : if a1 == one: return(f(a0))

#for (Prim in [Byte Int Long Float Double],
      zero in [0Y, 0, 0L, 0.0f, 0.0],
      one  in [1Y, 1, 1L, 1.0f, 1.0]) :

  defmethod lo-fold-binary-op (op:AddOp,     f:? -> EIns, a0:Prim, a1:Prim) : f(a0 + a1)
  defmethod lo-fold-binary-op (op:SubOp,     f:? -> EIns, a0:Prim, a1:Prim) : f(a0 - a1)
  defmethod lo-fold-binary-op (op:MulOp,     f:? -> EIns, a0:Prim, a1:Prim) : f(a0 * a1)
  defmethod lo-fold-binary-op (op:DivOp,     f:? -> EIns, a0:Prim, a1:Prim) : f(a0 / a1)
  defmethod lo-fold-binary-op (op:LtOp,      f:? -> EIns, a0:Prim, a1:Prim) : f(a0 < a1)
  defmethod lo-fold-binary-op (op:GtOp,      f:? -> EIns, a0:Prim, a1:Prim) : f(a0 > a1)
  defmethod lo-fold-binary-op (op:LeOp,      f:? -> EIns, a0:Prim, a1:Prim) : f(a0 <= a1)
  defmethod lo-fold-binary-op (op:GeOp,      f:? -> EIns, a0:Prim, a1:Prim) : f(a0 >= a1)
  defmethod lo-fold-binary-op (op:EqOp,      f:? -> EIns, a0:Prim, a1:Prim) : f(a0 == a1)
  defmethod lo-fold-binary-op (op:NeOp,      f:? -> EIns, a0:Prim, a1:Prim) : f(a0 != a1)

defmethod lo-partial-fold-binary-op (op:AddOp, f:? -> EIns, a0:?, a1:?) :   
  label<False|EIns> return :
    #for (Prim in [Byte Int Long Float Double],
          zero in [0Y,  0,  0L,  0.0f, 0.0]) :
      match(a0:Prim) : if a0 == zero: return(a1)
      match(a1:Prim) : if a1 == zero: return(a0)

defmethod lo-partial-fold-binary-op (op:SubOp, f:? -> EIns, a0:?, a1:?) :   
  label<False|EIns> return :
    #for (Prim in [Byte Int Long Float Double],
          zero  in [0Y, 0,  0L,  0.0f, 0.0]) :
       match(a1:Prim) : if a1 == zero: return(a0)

defmethod lo-partial-fold-binary-op (op:MulOp, f:? -> EIns, a0:?, a1:?) :   
  label<False|EIns> return :
    #for (Prim in [Byte Int Long Float Double],
          one  in [1Y,  1,  1L,  1.0f, 1.0]) :
      match(a0:Prim) : if a0 == one: return(a1)
      match(a1:Prim) : if a1 == one: return(a0)

defmulti hi-fold-unary-op (op:EOp, f:? -> EIns, a0:?) -> False|EIns

defmethod hi-fold-unary-op (op:EOp, f:? -> EIns, a0:?) : false

defmethod hi-fold-unary-op (op:IntNegOp, f:? -> EIns, a0:Int) : f(negate(a0))
defmethod hi-fold-unary-op (op:IntNotOp, f:? -> EIns, a0:Int) : f(bit-not(a0))

defmulti lo-fold-unary-op (op:EOp, f:? -> EIns, a0:?) -> False|EIns

defmethod lo-fold-unary-op (op:EOp, f:? -> EIns, a0:?) : false

#for (Prim in [Int Long Float Double]) :
  defmethod lo-fold-unary-op (op:NegOp, f:? -> EIns, a0:Prim) :    f(negate(a0))

#for (Prim in [Byte Int Long]) :
  defmethod lo-fold-unary-op (op:NotOp, f:? -> EIns, a0:Prim) :    f(bit-not(a0))

defn constant-fold (epackage:EPackage, ehier:EHier, gvt:VarTable, defstruct-table:IntTable<EDefStruct>, enabled?: Int -> True|False, changed?:IntSet) -> EPackage :
  val num-writes = IntTable<Int>(0)
  defn fold-in-body (e:EBody, top:False|Int, vt:VarTable) -> EBody :
    val bindings = IntTable<EImm>()
    defn type* (e:EImm) :
      match(e) :
        (e:ELiteral|ELSLiteral) :
          match(value(e)) :
            (v:EObject|ENewObject) : EOf(n(v))
            (v) : type(vt, e)
        (e:EVar) :
          match(get?(bindings, n(e))) :
           (e:ELiteral|ELSLiteral) : type*(e)
           (f) : type(vt, e)
        (e) :
          type(vt, e)
    defn hi-constant? (e:EImm) :
      match(e) :
       (e:ELiteral) : true
       (e:EVar) :
         val b  = get?(bindings, n(e))
         match(b:ELiteral) : value(b) is-not EObject
       (e) : false
    defn lo-constant? (e:EImm) :
      match(e) :
       (e:ELSLiteral) : true
       (e:EVar) :
         val b  = get?(bindings, n(e))
         match(b:ELSLiteral) : value(b) is-not EObject
       (e) : false
    defn constant-value (e:EImm) :
      match(e) :
        (e:ELiteral|ELSLiteral) : value(e)
        (e:EVar) : constant-value(bindings[n(e)]) when key?(bindings, n(e)) else e
        (e) : e
    defn maybe-changed (n:False|Int) : match(n:Int) : add(changed?, n)
    ;; println("CONSTANT-FOLDING ...")
    walk-writes(e, num-writes)
    defn walk (e:ELItem) -> ELItem :
      defn default () : map(walk, e)
      match(e) :
        (e:EVar) :
          ;; TODO: THIS SHOULD WORK AND IS NECESSARY FOR CONSTANT FOLDING
          ;; match(get?(bindings, n(e), e)) :
          ;;   (b:EVar) : b
          ;;   (b:ELiteral) : b when value(b) is-not EObject else e
          ;;   (b) : b
          e
        (e:ELive) :
          e
        (e:EObject) :
          println("DEFINING %_ -> %_" % [n(x(e)), ELiteral(e)]) when trace-constant-folding?
          bindings[n(x(e))] = ELiteral(e)
          map(walk, e)
        (e:ENewObject) :
          println("DEFINING %_ -> %_" % [n(x(e)), ELiteral(e)]) when trace-constant-folding?
          bindings[n(x(e))] = ELiteral(e)
          map(walk, e)
        (e:EDef) :
          if num-writes[n(x(e))] < 2 :
            match(y(e)) :
              (y:EVar) :
                println("DEFINING %_ -> %_" % [n(x(e)), get?(bindings, n(y), y)]) when trace-constant-folding?
                bindings[n(x(e))] = get?(bindings, n(y), y)
              (y:ELSLiteral|ELiteral) :
                println("DEFINING %_ -> %_" % [n(x(e)), y]) when trace-constant-folding?
                bindings[n(x(e))] = y
              (y) : false
          e
        (i:EPrim) :
          ;; println("CONSIDERING %_ -> %_" % [i, map(constant?, ys(i))])
          defn result (kind:String, value, f:? -> EImm) :
            maybe-changed(top)
            match(value) :
              (value:EImm) :
                println("%_ PRIM PARTIAL FOLDING %_ -> %_" % [kind, i, value]) when trace-constant-folding?
                EDef(x(i), value)
              (value) :
                val lit = match(value:EObject) : EVar(n(x(value)))
                          else : f(value)
                println("%_ PRIM FOLDING %_ -> %_" % [kind, i, lit]) when trace-constant-folding?
                bindings[n(x(i))] = lit
                EDef(x(i), lit)
          if any?(hi-constant?, ys(i)) :
            defn hi-result (value) : result("HI", value, ELiteral)
            defn hi-partial-result (value) : result("HI PARTIAL", value, ELiteral)
            val args = map(constant-value, ys(i))
            val res = switch { length(args) == _ } :
              1 : hi-fold-unary-op(op(i), hi-result, args[0])
              2 : if all?(hi-constant?, ys(i)) : hi-fold-binary-op(op(i), hi-result, args[0], args[1])
                  else : hi-partial-fold-binary-op(op(i), hi-partial-result, args[0], args[1])
              else : false
            match(res:EIns) : res
            else: i
          else if any?(lo-constant?, ys(i)) :
            defn lo-result (value) : result("LO", value, ELSLiteral)
            defn lo-partial-result (value) : result("LO PARTIAL", value, ELSLiteral)
            val args = map(constant-value, ys(i))
            val res = switch { length(args) == _ } :
              1 : lo-fold-unary-op(op(i), lo-result, args[0])
              2 : if all?(lo-constant?, ys(i)) : lo-fold-binary-op(op(i), lo-result, args[0], args[1])
                  else : lo-partial-fold-binary-op(op(i), lo-partial-result, args[0], args[1])
              else : false
            match(res:EIns) : res
            else: i
          else :
            i
        (i:EIf) :
          ;; println("CONSIDERING %_ -> %_" % [i, map(constant?, ys(i))])
          defn if-result (kind:String, res:True|False) :
            println("%_ IF FOLDING %_ -> %_" % [kind, i, res]) when trace-constant-folding?
            maybe-changed(top)
            EGoto(n1(i) when res else n2(i))
          if all?(hi-constant?, ys(i)) :
            val args = map(constant-value, ys(i))
            switch { length(args) == _ } :
              2 : match(hi-fold-binary-op(op(i) as EOp, if-result{"HI", _}, args[0], args[1])) :
                    (res:EIns)  : res
                    (res:False) : i
              else : i
          else if all?(lo-constant?, ys(i)) :
            val args = map(constant-value, ys(i))
            switch { length(args) == _ } :
              1 : if-result("LO", (args[0] as Int) == 1)
              2 : match(lo-fold-binary-op(op(i) as EOp, if-result{"LO", _}, args[0], args[1])) :
                    (res:EIns)  : res
                    (res:False) : i
              else : i
          else :
            i
        (e:EObjectGet) :
          match(y(e)) :
            (y:EVar) :
              match(get?(bindings, n(y), false)) :
                (l:ELiteral) :
                  match(value(l)) :
                    (o:ENewObject) :
                      maybe-changed(top)
                      println("---- FOLDING %_ / %_[%_]" % [e, o, index(e)]) when trace-constant-folding?
                      if index(e) > length(ys(o)) :
                        println("ERROR INDEX %_ EXCEEDS LENGTH OF %_" % [index(e), ys(o)])
                      walk(EDef(x(e), ys(o)[index(e)]))
                    (f:False) : default()
                (f) : default()
            (y) : default()
        ;; (e:ELoad) :
        ;;   match(loc(e)) :
        ;;     (f:EField) :
        ;;       match(loc(f)) :
        ;;         (l:EDeref) :
        ;;           match(y(l)) :
        ;;             (v:EVar) :
        ;;               match(get?(bindings, n(v), false)) :
        ;;                 (o:ELiteral) :
        ;;                   match(value(o)) :
        ;;                     (v:EObject) :
        ;;                       val ds = get?(defstruct-table, n(v))
        ;;                       match(ds:EDefStruct) :
        ;;                         if mutable?(base(ds)[index(f)]) :
        ;;                           default()
        ;;                         else :
        ;;                           println("OBJ FOLDING %_ -> %_" % [e, ys(v)[index(f)]])
        ;;                           maybe-changed(top)
        ;;                           walk(EDef(x(e), ys(v)[index(f)]))
        ;;                       else :
        ;;                         default()
        ;;                     (v:Float|Double|Int|Long|Byte) :
        ;;                       if index(f) == 0 :
        ;;                         ;; println("LIT FOLDING %_ -> %_" % [e, ELSLiteral(v)])
        ;;                         maybe-changed(top)
        ;;                         walk(EDef(x(e), ELSLiteral(v)))
        ;;                       else :
        ;;                         default()
        ;;                     (v) :
        ;;                       ;; println("NO  FOLDING %_ -> %_" % [e, v])
        ;;                       default()
        ;;                 (o) : default()
        ;;             (v) : default()
        ;;         (v) : default()
        ;;     (l) : default()
        (e) :
          map(walk, e)
    val ins* = for ins in ins(e) map : walk(ins) as EIns
    sub-ins(e, ins*)

  defn fold-texp (x:ETExp, vt:VarTable) :
    val top = match(x:EDefmethod|EDefn|EInit) : n(x)
    val result = let loop (x:ELBigItem = x) :
      match(x) :
        (e:EFn) :
          for a in args(e) do : num-writes[a] = 1
          map(loop, e)
        (e:EBody) :
          map(loop, fold-in-body(e, top, vt))
        (x) :
          map(loop, x)
    result as ETExp

  map-with-var-table(fold-texp, gvt, epackage, enabled?)

;============================================================
;=========== COMMON SUBEXPRESSION ELIMINATION ===============
;============================================================
deftype EVarLocIns :
  EPrim <: EVarLocIns
  ELoad <: EVarLocIns
  EObjectGet <: EVarLocIns
  ETupleGet <: EVarLocIns
  EConv <: EVarLocIns
  EInterpret <: EVarLocIns
  EDef <: EVarLocIns

defmulti varloc (e:EVarLocIns) -> EVarLoc

defmethod varloc (e:EPrim) : x(e)
defmethod varloc (e:ELoad) : x(e)
defmethod varloc (e:EObjectGet) : x(e)
defmethod varloc (e:ETupleGet) : x(e)
defmethod varloc (e:EConv) : x(e)
defmethod varloc (e:EInterpret) : x(e)
defmethod varloc (e:EDef) : x(e)

deftype EEqualable :
  EPrim <: EEqualable
  ELoad <: EEqualable
  EObjectGet <: EEqualable
  ETupleGet <: EEqualable
  EConv <: EEqualable
  EInterpret <: EEqualable
  EDef <: EEqualable
  EImm <: EEqualable
  ELoc <: EEqualable
  EOp <: EEqualable

;; TODO: THESE ARE ONLY BASIC-OPS -- WHAT OTHER OPS DO I NEED TO COVER?
public defn id (op:EOp) -> Int :
  match(op) :
    (op:IntAddOp) : 0
    (op:IntSubOp) : 1
    (op:IntMulOp) : 2
    (op:IntDivOp) : 3
    (op:IntModOp) : 4
    (op:IntAndOp) : 5
    (op:IntOrOp) : 6
    (op:IntXorOp) : 7
    (op:IntShlOp) : 8
    (op:IntShrOp) : 9
    (op:IntAshrOp) : 10
    (op:IntLtOp) : 11
    (op:IntGtOp) : 12
    (op:IntLeOp) : 13
    (op:IntGeOp) : 14
    (op:AddOp) : 15
    (op:SubOp) : 16
    (op:MulOp) : 17
    (op:DivOp) : 18
    (op:ModOp) : 19
    (op:AndOp) : 20
    (op:OrOp) : 21
    (op:XorOp) : 22
    (op:ShlOp) : 23
    (op:ShrOp) : 24
    (op:AshrOp) : 25
    (op:EqOp) : 26
    (op:NeOp) : 27
    (op:LtOp) : 28
    (op:GtOp) : 29
    (op:LeOp) : 30
    (op:GeOp) : 31
    (op:UleOp) : 32
    (op:UltOp) : 33
    (op:UgtOp) : 34
    (op:UgeOp) : 35
    (op:IntNotOp) : 36
    (op:IntNegOp) : 37
    (op:NegOp) : 38
    (op:NotOp) : 39
    (op:GCOp) : 40
    (op:ClassNameOp) : 41
    (op:PrintStackTraceOp) : 42
    (op:FlushVMOp) : 43
    (op:CRSPOp) : 44
    (op:EnterStackOp) : 45
    (op:YieldOp) : 46

public defn side-effecting? (op:EOp) -> True|False :
  match(op) :
    (op:GCOp) : true
    (op:PrintStackTraceOp) : true
    (op:FlushVMOp) : true
    (op:CRSPOp) : true
    (op:EnterStackOp) : true
    (op:YieldOp) : true
    (op) : false

;; defmulti cse-hash (a:EEqualable) -> Int
;; 
;; defmethod cse-hash (a:EPrim) -> Int :
;;   var i = length(ys(a))
;;   for y in ys(a) do :
;;      i = (7 * i) + cse-hash(y)
;;   cse-hash(op(a)) + 7 * i
;; 
;; defmethod cse-hash (a:EOp) : id(a)
;; defmethod cse-hash (a:EObjectGet) : cse-hash(y(a)) + 7 * hash(n(a)) + 49 * hash(index(a))
;; defmethod cse-hash (a:ETupleGet) : cse-hash(y(a)) + 7 * hash(index(a))
;; defmethod cse-hash (a:ELoad) : cse-hash(loc(a))
;; defmethod cse-hash (a:EConv) : cse-hash(y(a))
;; defmethod cse-hash (a:EInterpret) : cse-hash(y(a))
;; defmethod cse-hash (a:EDef) : cse-hash(y(a) as EImm) when y(a) is EImm else 0
;; defmethod cse-hash (a:EImm) : 0
;; defmethod cse-hash (a:ELSLiteral) : hash(value(a))
;; defmethod cse-hash (a:ELiteral) : hash(value(a))
;; defmethod cse-hash (a:EVar) : hash(n(a))
;; defmethod cse-hash (a:EVarLoc) : hash(n(a))
;; defmethod cse-hash (a:EDeref) : cse-hash(y(a))
;; defmethod cse-hash (a:EDeptr) : cse-hash(y(a))
;; defmethod cse-hash (a:EField) : cse-hash(loc(a)) + 7 * hash(n(a)) + 49 * hash(index(a))
;; defmethod cse-hash (a:ESlot) : cse-hash(loc(a)) + 7 * cse-hash(index(a))

defmulti cse-equal? (a:EEqualable, b:EEqualable) -> True|False

defmethod cse-equal? (a:EEqualable, b:EEqualable) : false
defmethod cse-equal? (a:EOp, b:EOp) : id(a) == id(b)
defmethod cse-equal? (a:EPrim, b:EPrim) : cse-equal?(op(a), op(b)) and all?(cse-equal?, ys(a), ys(b)) 
defmethod cse-equal? (a:EObjectGet, b:EObjectGet) : cse-equal?(y(a), y(b)) and n(a) == n(b) and index(a) == index(b)
defmethod cse-equal? (a:ETupleGet, b:ETupleGet) : cse-equal?(y(a), y(b)) and index(a) == index(b)
defmethod cse-equal? (a:ELoad, b:ELoad) : cse-equal?(loc(a), loc(b))
defmethod cse-equal? (a:EConv, b:EConv) : cse-equal?(y(a), y(b))
defmethod cse-equal? (a:EInterpret, b:EInterpret) : cse-equal?(y(a), y(b))
defmethod cse-equal? (a:EDef, b:EDef) :
  match(y(a), y(b)) :
    (ai:EImm, bi:EImm) : cse-equal?(ai, bi)
    (af, bf) : false
defmethod cse-equal? (a:ELSLiteral, b:ELSLiteral) : value(a) == value(b)
defmethod cse-equal? (a:ELiteral, b:ELiteral) : value(a) == value(b)
defmethod cse-equal? (a:EVar, b:EVar) : n(a) == n(b)
defmethod cse-equal? (a:EVarLoc, b:EVarLoc) : n(a) == n(b)
defmethod cse-equal? (a:EDeref, b:EDeref) : cse-equal?(y(a), y(b))
defmethod cse-equal? (a:EDeptr, b:EDeptr) : cse-equal?(y(a), y(b))
defmethod cse-equal? (a:EField, b:EField) : cse-equal?(loc(a), loc(b)) and n(a) == n(b) and index(a) == index(b)
defmethod cse-equal? (a:ESlot, b:ESlot) : cse-equal?(loc(a), loc(b)) and cse-equal?(index(a), index(b))

defmulti cseable? (a:EEqualable, mut?:Int -> True|False) -> True|False

defmethod cseable? (a:EEqualable, mut?:Int -> True|False) : true
defmethod cseable? (a:EPrim, mut?:Int -> True|False) : cseable?(op(a), mut?) and all?(cseable?{_, mut?}, ys(a))
defmethod cseable? (a:EOp, mut?:Int -> True|False) : not side-effecting?(a)
defmethod cseable? (a:EObjectGet, mut?:Int -> True|False) : cseable?(y(a), mut?)
defmethod cseable? (a:ETupleGet, mut?:Int -> True|False) : cseable?(y(a), mut?)
defmethod cseable? (a:ELoad, mut?:Int -> True|False) : cseable?(loc(a), mut?)
defmethod cseable? (a:EConv, mut?:Int -> True|False) : cseable?(y(a), mut?)
defmethod cseable? (a:EInterpret, mut?:Int -> True|False) : cseable?(y(a), mut?)
defmethod cseable? (a:EVar, mut?:Int -> True|False) : not mut?(n(a))
defmethod cseable? (a:EVarLoc, mut?:Int -> True|False) : mut?(n(a))
defmethod cseable? (a:EDeref, mut?:Int -> True|False) : cseable?(y(a), mut?)
defmethod cseable? (a:EDeptr, mut?:Int -> True|False) : cseable?(y(a), mut?)
defmethod cseable? (a:EField, mut?:Int -> True|False) : cseable?(loc(a), mut?)
defmethod cseable? (a:ESlot, mut?:Int -> True|False) : cseable?(loc(a), mut?) and cseable?(index(a), mut?)
defmethod cseable? (a:EDef, mut?:Int -> True|False) :
  match(y(a)) :
    (e:EImm) : cseable?(e, mut?)
    (e:False) : true

; Based on https://tanujkhattar.wordpress.com/2016/01/11/dominator-tree-of-a-directed-graph/
defstruct DominatorNode :
  id : Int
  nbrs : Tuple<Int>
  tree : Vector<Int> with: (init => Vector<Int>())
  rg : Vector<Int> with: (init => Vector<Int>())
  bucket : Vector<Int> with: (init => Vector<Int>())
  sdom : Int with: (setter => set-sdom, init => 0)
  par : Int with: (setter => set-par, init => 0)
  dom : Int with: (setter => set-dom, init => 0)
  dsu : Int with: (setter => set-dsu, init => 0)
  lab : Int with: (setter => set-lab, init => 0)
  arr : Int with: (setter => set-arr, init => 0)
  rev : Int with: (setter => set-rev, init => 0)

defstruct DominatorGraph :
  nodes : Vector<DominatorNode> with: (init => Vector<DominatorNode>())

defn get (g:DominatorGraph, i:Int) : nodes(g)[i]

defn find (g:DominatorGraph, u:Int, x:Int) :
  val node = g[u]
  if u == dsu(node) :
    -1 when x > 0 else u
  else :
    val v = find(g, dsu(node), x + 1)
    if v < 0 :
      u
    else :
      if sdom(g[lab(g[dsu(node)])]) < sdom(g[lab(node)]) :
        set-lab(node, lab(g[dsu(node)]))
      set-dsu(node, v)
      v when x == 0 else lab(node)

defn union (g:DominatorGraph, u:Int, v:Int) : ;; Add an edge u-->v
  set-dsu(g[v], u)

defn dfs0 (g:DominatorGraph, u:Int) :
  var T:Int = 0
  let loop (u:Int = u) :
    T = T + 1
    set-arr(g[u], T)
    set-rev(g[T], u)
    set-lab(g[T], T)
    set-sdom(g[T], T)
    set-dsu(g[T], T)
    for w in nbrs(g[u]) do :
      if arr(g[w]) == 0 :
        loop(w)
        set-par(g[arr(g[w])], arr(g[u]))
      add(rg(g[arr(g[w])]), arr(g[u]))
  T

defn dump (g:DominatorGraph) :
  let loop (u:Int = 1, p:Int = 1, d:Int = 0) :
    for j in 0 to d do: print("  ")
    println(u)
    for w in tree(g[u]) do :
      if w != p :
        loop(w, u, d + 1)

defn to-dominator-tree (g:DominatorGraph) -> Seq<KeyValue<Int,Tuple<Int>>> :
  generate<KeyValue<Int, Tuple<Int>>> :
    let loop (u:Int = 1, p:Int = 1) :
      val children = to-tuple $ for w in tree(g[u]) filter : w != p
      val out-children = to-tuple $ for c in children seq : id(g[c])
      yield(id(g[u]) => out-children)
      for w in children do :
        loop(w, u)

defn DominatorTree (iinput:Seqable<KeyValue<Int,Tuple<Int>>>) -> Tuple<KeyValue<Int,Tuple<Int>>> :
  val g = DominatorGraph()
  val input = to-tuple $ iinput
  ;; println("INPUT = %_" % [input])
  val aliases = IntTable<Int>()
  for (elt in input, i in 1 to false) do :
    aliases[key(elt)] = i
  add(nodes(g), DominatorNode(-1, []))
  for kv in input do :
    val nbrs = to-tuple $ for c in value(kv) seq : aliases[c]
    add(nodes(g), DominatorNode(key(kv), nbrs)) 
  val n = dfs0(g, 1)
  for i in n through 1 by -1 do :
    for j in 0 to length(rg(g[i])) do :
      set-sdom(g[i], min(sdom(g[i]), sdom(g[find(g, rg(g[i])[j], 0)])))
    if i > 1 :
      add(bucket(g[sdom(g[i])]), i)
    for w in bucket(g[i]) do :
      val v = find(g, w, 0)
      if sdom(g[v]) == sdom(g[w]) :
        set-dom(g[w], sdom(g[w]))
      else :
        set-dom(g[w], v)
    if i > 1 :
      union(g, par(g[i]), i)
  for i in 2 through n do :
    if dom(g[i]) != sdom(g[i]) :
      set-dom(g[i], dom(g[dom(g[i])]))
    add(tree(g[rev(g[i])]), rev(g[dom(g[i])]))
    add(tree(g[rev(g[dom(g[i])])]), rev(g[i]))
  val res = to-tuple $ to-dominator-tree(g)
  ;; println("OUTPUT = %_" % [res])
  res

defn common-subexpression-elimination (epackage:EPackage, gvt:VarTable) -> EPackage :
  val num-writes = IntTable<Int>(0)
  defn lookup? (values:List<KeyValue<EEqualable,EVarLocIns>>, e:EEqualable) -> False|EVarLocIns :
    let loop (elts:List<KeyValue<EEqualable,EVarLocIns>> = values) :
      if empty?(elts) :
        false
      else :
        val elt = head(elts)
        if cse-equal?(key(elt), e) :
          value(elt)
        else :
          loop(tail(elts))
  defn fold-in-body (e:EBody, vt:VarTable) -> EBody :
    val bindings = IntTable<EImm>()
    ;; println("CSE ...")
    walk-writes(e, num-writes)
    ; val args = to-intset(iargs)
    val aliases = IntTable<Int>()
    defn mut? (n:Int) : num-writes[n] > 1
    var found?:True|False = false

    ;; TODO: SHOULD SPLIT THIS OUT AND RENAME FIRST AS SEPARATE PASS
    val vars = to-inttable<ELocal> $ for l in locals(e) seq : n(l) => l
    ;; TODO: REDO ALONG LINES OF DEAD-CODE-ELIMINATION
    defn renameable? (n:Int) -> True|False :
      (key?(vars, n) and not mutable?(vars[n])) ; or args[n]
    defn* rename (e:ELItem) :
      match(e) :
        (e:EDef) :
          match(y(e)) :
            (y:EVar) :
              if renameable?(n(y)) and not mut?(n(x(e))) :
                aliases[n(x(e))] = get?(aliases, n(y), n(y))
              sub-y(e, rename(y) as EVar)
            (y) :
              e
        (e:EVar|EVarLoc|ETagof) :
          if key?(aliases, n(e)) :
            sub-n(e, aliases[n(e)])
          else :
            e
        (e:ELive) :
          e
        (e) :
          map(rename, e)

    val block-tbl = analyze-basic-blocks(ins(e))
    val graph = for b in block-tbl seq : lbl(b) => successors(b)
    val tree = to-tuple $ DominatorTree(graph)
    val links = to-inttable<Tuple<Int>> $ tree
    val ins* = to-tuple $ generate<EIns> :
      let loop (block:BBlock = next(to-seq(block-tbl)), ivalues:List<KeyValue<EEqualable,EVarLocIns>> = List()) :
        ;; println("+++ WALKING %_" % [lbl(block)])
        var values = ivalues
        defn walk (e:ELItem) -> ELItem :
          match(e) :
            (e:EDef|EPrim|EObjectGet|ETupleGet|ELoad|EConv|EInterpret) :
              if mut?(n(x(e))) or not cseable?(e, mut?) :
                e
              else :
                match(lookup?(values, e)) :
                  (ne:EVarLocIns) : (found? = true, EDef(x(e), EVar(n(varloc(ne))))) ;println("REPLACING %_ => %_" % [e, ne])
                  (fe:False) :      (values = cons(e => e, values), e)
            (e) :
              e
        ;; for ins in instructions(block) do : yield(walk(rename(ins)) as EIns)
        for ins in instructions(block) do : yield(walk(ins) as EIns)
        for cbi in links[lbl(block)] do : loop(block-tbl[cbi], values)

    ;; if found? :
    ;;   println("--- BEFORE ---")
    ;;   for ins in ins(e) do : println(ins)
    ;;   println("--- AFTER  ---")
    ;;   for ins in ins* do : println(ins)
    sub-ins(e, ins*)

  defn fold-texp (x:ETExp, vt:VarTable) :
    val result = let loop (x:ELBigItem = x) :
      ;; match(x:EDefn) : println("DEFN %_" % [n(x)])
      match(x) :
        (e:EFn) :
          for a in args(e) do : num-writes[a] = 1
          map(loop, e)
        (e:EBody) :
          fold-in-body(e, vt)
        (x) :
          match(map(loop, x)) :
            (e:EBody) :
              fold-in-body(e, vt)
            (e) :
              e
    result as ETExp

  map-with-var-table(fold-texp, gvt, epackage)

;============================================================
;=================== RESOLVE MATCHES ========================
;============================================================
defn resolve-matches-coverage (epackage:EPackage, ehier:EHier, gvt:VarTable) -> EPackage :
  defn resolve-in-body (e:EBody, vt:VarTable) -> EBody :
    val ins* = for i in ins(e) map :
      match(i) :
        (i:EMatch) :
          if length(ys(i)) == 1 :
            val ys-type = type(vt, ys(i)[0])
            val combined-branch-type = union $ seq({types(_)[0]}, branches(i))
            val covered? = subtype?(ehier, ys-type, combined-branch-type)
            sub-covered?(i, covered?)
          else :
            i
        (i) : i
    sub-ins(e, ins*)
  defn resolve-texp (x:ETExp, vt:VarTable) :
    val result = let loop (x:ELBigItem = x) :
      match(map(loop, x)) :
        (e:EBody) : resolve-in-body(e,vt)
        (e) : e
    result as ETExp
  map-with-var-table(resolve-texp, gvt, epackage)

defn union (input-ts:Seqable<EType>) :
  val ts = to-seq(input-ts)
  if empty?(ts) : EBot()
  else : reduce(EOr, ts)

;============================================================
;=================== Closure Lifting ========================
;============================================================

defn lift-closures (epackage:EPackage, gvt:VarTable) -> EPackage :
  ;Track new top level expressions
  val new-texps = Vector<ETExp>()

  ;Lift the given function with the computed free vars to the top-level.
  ;- Use closure as the identifier of the closure argument.
  ;- Write a recursive function to compute translated EFn.
  ;  - For every EFn:
  ;    - Retrieve the free variables from closure argument
  ;    - Retrieve the type variables from closure argument
  ;    - Rename all instructions, input types, and output types
  ;- Construct EDefClosure expression and add to top level.
  ;- Returns the identifier used for the DefClosure expression.
  defn lift-to-defclosure (f:EFunction, fnfree:Free, vt:VarTable) -> Int :
    ;DefClosure identifier
    val fid = uniqueid()

    ;Closure argument
    val closure = uniqueid()

    ;Helper function for processing the body of an EFunction
    defn lift (e:ELBigItem) -> ELBigItem :
      match(e:EFn) :
        ;Track necessary renames
        val rename-table = IntTable<Int>()
        defn rename-var (v:Int) :
          val v* = uniqueid()
          rename-table[v] = v*
          v*

        ;Create buffer
        val buffer = BodyBuffer(body(e))

        ;Retrieve free variables from closure argument
        for v in vars(free(e)) do :
          val i = index-of(vars(fnfree), v)
          match(i:Int) :
            val v* = rename-var(v)
            val t = type(vt,v)
            emit(buffer, ELocal(v*, t, false))
            emit(buffer, EClosureGet(EVarLoc(v*), EVar(closure), fid, i))

        ;Retrieve type variables from closure argument
        for v in tvars(free(e)) do :
          val i = index-of!(tvars(fnfree), v)
          val v* = rename-var(v)
          emit(buffer, ELocalType(v*))
          emit(buffer, EClosureTGet(ETVarLoc(v*), EVar(closure), fid, i))

        ;Check that recursion has been done
        fatal("Closures not yet lifted!") when not empty?(localfns(body(e)))
        fatal("Objects not yet lifted!") when not empty?(localobjs(body(e)))

        ;Emit renamed body
        for i in ins(body(e)) do :
          emit(buffer, rename-vars+tvars(i,rename-table))

        ;Return new function
        defn remove-nonlocal-tvars (t:EType) -> EType :
          match(t:ETVar) : ETop() when key?(rename-table,n(t)) else t
          else : map(remove-nonlocal-tvars, t)
        val a1* = map(remove-nonlocal-tvars, a1(e))
        val a2* = rename-vars+tvars(a2(e), rename-table)
        EFn(tail?(e), targs(e), args(e), a1*, a2*, to-body(buffer), info(e))
      else :
        map(lift, e)

    ;Construct EDefClosure and push to top level
    val ntargs = length(tvars(fnfree))
    val nargs = length(vars(fnfree))
    val func* = lift(f) as EFunction
    add(new-texps, EDefClosure(fid, closure, ntargs, nargs, func*))

    ;Return the DefClosure identifier
    fid

  ;Sweep through the body and lift out declarations of local functions
  ;- Lift each function to the top level
  ;- Sweep through instructions, and convert EInitClosures into ELetRec statements.
  ;  - Create each closure by looking up its freevars in free-table
  ;- Return new function
  ;  - The local functions are now empty, and moved over to local definitions
  ;  - Use the new instructions
  defn lift-body (e:EBody, vt:VarTable) :
    ;Track the freevars for each function
    val free-table = IntTable<Free>()

    ;Track the identifiers for each function
    val closureid-table = IntTable<Int>()

    ;Lift each function to the top level
    for f in localfns(e) do :
      ;Compute freevars
      val fnfree = match(func(f)) :
        (f:EFn) : free(f)
        (f:EMultifn) : join-free(seq(free, funcs(f)))
      free-table[n(f)] = fnfree
      ;Lift function
      closureid-table[n(f)] = lift-to-defclosure(func(f), fnfree, vt)

    ;Generate new instructions
    val buffer = BodyBuffer(e)
    for i in ins(e) do :
      match(i) :
        (i:EInitClosures) :
          val xs* = Vector<EVarLoc>()
          val closures* = Vector<EClosure>()
          for x in xs(i) do :
            val free = free-table[n(x)]
            val closureid = closureid-table[n(x)]
            if empty?(free):
              emit(buffer, EDef(x, EConstClosure(closureid)))
            else :
              val targs = map(ETVar, tvars(free))
              val ys = map(EVar, vars(free))
              add(xs*, x)
              add(closures*, EClosure(closureid, targs, ys))
            emit(buffer, ELocal(n(x), EOf(n(iotable(vt),CORE-FN-ID)), false))
          if not empty?(xs*) :
            emit(buffer, ELetRec(to-tuple(xs*), to-tuple(closures*), info(i)))
        (i) :
          emit(buffer, i)

    ;Return body
    to-body(buffer, true, false, true)

  defn analyze (e:ELBigItem, vt:VarTable) -> ELBigItem :
    ;; match(e:EDefn|EDefmethod) : println("--- LIFTING %_" % [n(e)])
    match(map(analyze{_, vt},e)) :
      (e:EBody) : lift-body(e,vt)
      (e) : e
  val epackage* = within (texp, vt) = map-with-var-table(gvt, epackage) :
    val texp* = analyze-freevars(texp,vt)
    analyze(texp*, vt) as ETExp
  add-exps(epackage*, new-texps)

;============================================================
;=============== Force Remove Type Objects ==================
;============================================================

defn force-remove-types (epackage:EPackage) :
  defn remove-from (e:ELItem) :
    match(map(remove-from,e)) :
      ;Top-level expressions
      (e:EDefmulti) : sub-targs(e, [])
      ;Small expressions
      (e:EFn) : sub-targs(e, [])
      (e:ECurry) : x(e)
      (e:EMethod) : sub-targs(e, [])
      (e:ETVar) : ETop()
      ;Unexpected expressions
      (e:EDefClosure) : fatal("Unexpected")
      (e:EDefObject) : fatal("Unexpected")
      (e:ENewObject) : fatal("Unexpected")
      (e:EClosureTGet) : fatal("Unexpected")
      (e:EObjectTGet) : fatal("Unexpected")
      (e:EClosure) : fatal("Unexpected")
      (e:ETypeObject) : fatal("Unexpected")
      (e:EDefTypeObject) : fatal("Unexpected")
      ;Default
      (e) : e
  remove-from(epackage) as EPackage

;============================================================
;================= Lifting Type Objects =====================
;============================================================

defn lift-type-objects (epackage:EPackage) :
  ;Store lifted types
  val type-table = HashTable<EType,EDefTypeObject>()

  ;Lift a type to the top level
  ;Returns the id of the deftype object.
  defn lift-to-deftype-object (t:EType, nargs:Int) -> Int :
    if not key?(type-table,t) :
      val n = uniqueid()
      type-table[t] = EDefTypeObject(n, nargs, t)
    n(type-table[t])

  ;Reindex a type
  defn reindex (t:EType) -> [EType, Tuple<ETVar>] :
    val table = IntTable<Int>()
    val tvars = Vector<Int>()
    val t* = let loop (t:EType = t) :
      match(t:ETVar) :
        if not key?(table, n(t)) :
          val i = length(tvars)
          table[n(t)] = i
          add(tvars, n(t))
        ETVar(table[n(t)])
      else : map(loop, t)
    [normalize(t*), to-tuple(seq(ETVar,tvars))]

  ;Lift all first-class types in body
  defn lift-body (e:EBody) :
    val buffer = BodyBuffer(e)

    ;Reify a type
    defn reify-type (t:EType) -> ETVar :
      match(t) :
        (t:ETVar) :
          t
        (t) :
          val [t*, tvars] = reindex(t)
          val n = lift-to-deftype-object(t*, length(tvars))
          val x = uniqueid()
          emit(buffer, ELocalType(x))
          if empty?(tvars) :
            emit(buffer, ETDef(ETVarLoc(x), EConstType(n)))
          else :
            emit(buffer, ETypeObject(ETVarLoc(x), n, tvars))
          ETVar(x)
    defn reify-type (e:EImm) -> EImm :
      match(e) :
        (e:ECurry) : ECurry(x(e), map(reify-type,targs(e)))
        (e) : e
    defn reify-type (e:EClosure) :
      sub-targs(e, map(reify-type,targs(e)))

    ;Reify all type arguments in instructions
    for i in ins(e) do :
      emit{buffer, _} $ match(i) :
        (i:ECall|ETCall) : sub-f(i, reify-type(f(i)))
        (i:ELetRec) : sub-ys(i, map(reify-type,ys(i)))
        (i:ENewObject) : sub-targs(i, map(reify-type, targs(i)))
        (i:ECheckFail) : ECheckFail(reify-type(type(i)), y(i), ctxt(i), info(i))
        (i) : i

    ;Return new body
    to-body(buffer)

  ;Recursively lift all bodies
  defn analyze (e:ELBigItem) -> ELBigItem :
    match(map(analyze,e)) :
      (e:EBody) : lift-body(e)
      (e) : e
  sub-exps(epackage, exps*) where :
    val analyzed-exps = for e in exps(epackage) map :
      analyze(e) as ETExp
    val exps* = to-tuple(cat(analyzed-exps, values(type-table)))

;============================================================
;====================== EType Conversion ====================
;============================================================

public defn to-etype (table:IOTable, t:DType, targs:Tuple<EType>) -> EType :
  defn conv (f:False) : false
  defn conv (ds:Tuple<DType>) : map(conv, ds)
  defn conv (d:DType) :
    match(d) :
      (d:DByte) : EByte()
      (d:DInt) : EInt()
      (d:DLong) : ELong()
      (d:DFloat) : EFloat()
      (d:DDouble) : EDouble()
      (d:DUnknown) : EUnknown()
      (d:DPtrT) : EPtrT()
      (d:DFnT) : EFnT(conv(a(d)), conv(r(d)), conv(b(d)))
      (d:DStructT) : EStructT(n(table,id(d)))
      (d:DOf) : EOf(n(table,id(d)))
      (d:DTVar) : targs[index(d)]
      (d:DCap) : conv(tvar(d))
      (d:DAnd) : reduce(EAnd, seq(conv, types(d)))
      (d:DOr) : reduce(EOr, seq(conv, types(d)))
      (d:DTop) : ETop()
      (d:DBot) : EBot()
      (d:DArrow) : EOf(n(table,CORE-FN-ID))
      (d:DTuple) : EOf(n(table,CORE-TUPLE-ID))
  conv(t)

;============================================================
;======================== VarTable ==========================
;============================================================

;For representing entries to declared functions
deftype FnEntry
defstruct EFnEntry <: FnEntry :
  targs: Tuple<Int>
  a1: Tuple<EType>
  r: EType|False
  a2: EType
  lostanza?: True|False
  tail?: True|False
with:
  printer => true

defstruct DFnEntry <: FnEntry :
  ntargs: Int
  a1: Tuple<DType>
  r: DType|False
  a2: DType
  lostanza?: True|False
  tail?: True|False
with:
  printer => true

defstruct EMultifnEntry <: FnEntry :
  funcs: Tuple<EFnEntry>
with:
  printer => true

;For representing entries to declared variables
defstruct VarEntry :
  mutable?: True|False
  type: EType|DType
  lostanza?: True|False
with:
  printer => true

;Basic table for holding VTEntry
deftype VarTable
defmulti get (e:VarTable, n:Int) -> VTRecord
defmulti key? (e:VarTable, n:Int) -> True|False
defmulti iotable (e:VarTable) -> IOTable
defn VarTable (records:Seqable<VTRecord>, iotable:IOTable, parent:VarTable|False) :
  ;Initialize table, convert varentry if necessary
  val table = to-inttable<VTRecord> $
    for r in records seq :
      n(r) => match(entry(r)) :
        (e:VarEntry) :
          match(type(e)) :
            (t:DType) :
              val et = to-etype(iotable, t, [])
              sub-entry(r, VarEntry(mutable?(e), et, lostanza?(e)))
            (t:EType) : r
        (e) : r
  new VarTable :
    defmethod get (this, n:Int) :
      match(get?(table, n), parent) :
        (r:VTRecord, p) : r
        (r:False, p:VarTable) : p[n]
        (r:False, p:False) : fatal("No entry for %_" % [n])
    defmethod key? (this, n:Int) :
      key?(table, n)
    defmethod iotable (this) :
      iotable
    defmethod print (o:OutputStream, this) :
      print(o, "VAR-TABLE(%_ PARENT %_)" % [to-tuple $ table, parent])

defstruct VTRecord :
  global?: True|False
  n: Int
  entry: FnEntry|VarEntry with: (updater => sub-entry)

;Convenience Functions
defn function? (vt:VarTable, n:Int) :
  entry(vt[n]) is FnEntry

defn tail? (vt:VarTable, n:Int, arity:Int) :
  defn tail? (e:FnEntry) :
    match(e) :
      (e:EFnEntry) : /tail?(e)
      (e:DFnEntry) : /tail?(e)
      (e:EMultifnEntry) :
        tail?(find!({length(a1(_)) == arity}, funcs(e)))
  tail?(entry(vt[n]) as FnEntry)

defn variable? (vt:VarTable, n:Int) :
  entry(vt[n]) is VarEntry

defn lostanza? (vt:VarTable, n:Int) :
  match(entry(vt[n])) :
    (e:EFnEntry) : lostanza?(e)
    (e:DFnEntry) : lostanza?(e)
    (e:VarEntry) : lostanza?(e)
    (e:EMultifnEntry) : false

defn type (vt:VarTable, e:EImm) :
  match(e) :
    (e:ELSLiteral) :
      match(value(e)) :
        (v:Byte) : EByte()
        (v:Char) : EByte()
        (v:Int) : EInt()
        (v:Long) : ELong()
        (v:Float) : EFloat()
        (v:Double) : EDouble()
        (v:True) : EOf(n(iotable(vt), CORE-TRUE-ID))
        (v:False) : EOf(n(iotable(vt), CORE-FALSE-ID))
        (v:String) : EPtrT()
    (e:ELiteral) :
      match(value(e)) :
        (v:Byte) : EOf(n(iotable(vt), CORE-BYTE-ID))
        (v:Char) : EOf(n(iotable(vt), CORE-CHAR-ID))
        (v:Int) : EOf(n(iotable(vt), CORE-INT-ID))
        (v:Long) : EOf(n(iotable(vt), CORE-LONG-ID))
        (v:Float) : EOf(n(iotable(vt), CORE-FLOAT-ID))
        (v:Double) : EOf(n(iotable(vt), CORE-DOUBLE-ID))
        (v:True) : EOf(n(iotable(vt), CORE-TRUE-ID))
        (v:False) : EOf(n(iotable(vt), CORE-FALSE-ID))
        (v:List) : EOf(n(iotable(vt), CORE-LIST-ID))
        (v:String) : EOf(n(iotable(vt), CORE-STRING-ID))
        (v:Symbol) : EOf(n(iotable(vt), CORE-SYMBOL-ID))
    (e:EVar) : type(vt,n(e))
    (e:ESizeof) : ELong()
    (e:ETagof) : ELong()

defn global? (vt:VarTable, n:Int) :
  global?(vt[n])

defn mutable? (vt:VarTable, n:Int) :
  match(entry(vt[n])) :
    (e:VarEntry) : mutable?(e)
    (e:FnEntry) : false

defn type (vt:VarTable, n:Int) :
  match(entry(vt[n])) :
    (e:VarEntry) : type(e) as EType
    (e:FnEntry) : EOf(/n(iotable(vt), CORE-FN-ID))

defn arities (vt:VarTable, n:Int) :
  match(entry(vt[n])) :
    (e:DFnEntry) : [length(a1(e))]
    (e:EFnEntry) : [length(a1(e))]
    (e:EMultifnEntry) : map(length{a1(_)}, funcs(e))

;Retrieve the argument and return types of a function
defn fn-types (vt:VarTable, f:EVar|ECurry, arity:Int) :
  val [n, targs] = match(f) :
    (f:EVar) : [n(f), []]
    (f:ECurry) : [n(x(f)), targs(f)]
  fn-types(vt, n, arity, targs)

defn fn-types (vt:VarTable, n:Int, arity:Int, targs:Tuple<EType>) :
  ;Extend with rest type indefinitely
  defn ex<?T> (xs:Tuple<?T>, y:?T|False) :
    match(y:False) : xs
    else : cat(xs, repeat(y as T))

  ;Conversion to etype
  defn to-etype (t:DType) :
    /to-etype(iotable(vt), t, targs)

  let loop (e:FnEntry = entry(vt[n]) as FnEntry) :
    match(e) :
      (e:DFnEntry) :
        fatal("Incorrect type arity.") when ntargs(e) != length(targs)
        val a1* = to-tuple $ take-n{arity, _} $
          seq(to-etype, ex(a1(e), r(e)))
        val a2* = to-etype(a2(e))
        [a1*, a2*]
      (e:EFnEntry) :
        fatal("Incorrect type arity.") when length(/targs(e)) != length(targs)
        val table = to-inttable<EType>(/targs(e), targs)
        val a1* = to-tuple $ take-n{arity, _} $
          seq(sub-tvars{_, table}, ex(a1(e), r(e)))
        val a2* = sub-tvars(a2(e), table)
        [a1*, a2*]
      (e:EMultifnEntry) :
        loop(find!({length(a1(_)) == arity}, funcs(e)))

defn GlobalVarTable (epackage:EPackage, iotable:IOTable) -> VarTable :
  ;Find records
  val imported-records = for import in imports(packageio(epackage)) seq? :
    val e = match(rec(import)) :
      (r:FnRec|MultiRec|ExternFnRec) :
        val id = id(r) as FnId
        val [lostanza?, tail?] =
          match(r) :
            (r:FnRec) : [lostanza?(r), tail?(r)]
            (r:MultiRec) : [false, false]
            (r:ExternFnRec) : [true, false]
        DFnEntry(ntargs(id) + ncargs(id), a1(id), false, a2(r), lostanza?, tail?)
      (r:ValRec) :
        VarEntry(mutable?(r), type(r), lostanza?(r))
      (r:ExternRec) :
        match(type(r)) :
          (t:DFnT) : DFnEntry(0, a(t), /r(t), b(t), true, false)
          (t) : VarEntry(true, type(r), true)
      (r) : false
    match(e:FnEntry|VarEntry) : One(VTRecord(true, n(import), e))
    else : None()
  val exported-records = for exp in exps(epackage) seq? :
    val [n, e] = match(exp) :
      (e:EDefn) : [n(e) FnEntry(func(e), lostanza?(e))]
      (e:EDefmethod) : [n(e), FnEntry(func(e), lostanza?(e))]
      (e:EDefmulti) : [n(e), EFnEntry(targs(e), a1(e), false, a2(e), false, false)]
      (e:EExternFn) : [n(e), FnEntry(func(e), true)]
      (e:EDefGlobal) : [n(e), VarEntry(mutable?(e), type(e), lostanza?(e))]
      (e:EExtern) :
        match(type(e)) :
          (t:EFnT) : [n(e), EFnEntry([], a(t), r(t), b(t), true, false)]
          (t) : [n(e), VarEntry(true, type(e), true)]
      (e) : [0, false]
    match(e:FnEntry|VarEntry) : One(VTRecord(true, n, e))
    else : None()

  ;Return populated vartable
  VarTable(cat(imported-records, exported-records), iotable, false)

defn LocalVarTable (gvt:VarTable, e:ETExp) -> VarTable :
  ;Find records
  val records = generate<VTRecord> :
    defn found (n:Int, e:FnEntry|VarEntry) :
      yield(VTRecord(false, n, e))
    ;Determine whether we are in a LoStanza context
    val lostanza-context? = match(e) :
      (e:EDefn) : lostanza?(e)      
      (e:EDefClosure) : false
      (e:EDefmethod) : lostanza?(e)
      (e:EExternFn) : true
      (e:EInit) : lostanza?(e)
      (e:EDefObject) : false
      (e) : false
    let loop (e:ELBigItem = e) :
      match(e) :
        (e:EFn) :
          for (x in args(e), t in a1(e)) do :
            found(x, VarEntry(false, t, lostanza-context?))
        (e:EBody) :
          for e in localfns(e) do :
            found(n(e), FnEntry(func(e), lostanza-context?))
          for e in locals(e) do :
            found(n(e), VarEntry(mutable?(e), type(e), lostanza-context?))
        (e) : false
      do*(loop, e)

  ;Return populated table
  VarTable(records, iotable(gvt), gvt)

defn FnEntry (e:EFunction, lostanza?:True|False) :
  match(e) :
    (e:EFn) : EFnEntry(targs(e), a1(e), false, a2(e), lostanza?, tail?(e))
    (e:EMultifn) : EMultifnEntry(map({FnEntry(_, lostanza?) as EFnEntry}, funcs(e)))

;============================================================
;====================== Utilities ===========================
;============================================================

defn add-exps (ep:EPackage, exps*:Seqable<ETExp>) :
  sub-exps(ep, to-tuple(cat(exps(ep), exps*)))

;Join the sequence of Free structures.
defn join-free (fs:Seqable<Free>) :
  val var-set = IntSet()
  val tvar-set = IntSet()
  for f in fs do :
    add-all(var-set, vars(f))
    add-all(tvar-set, tvars(f))
  Free(to-tuple(var-set), to-tuple(tvar-set))

;Compute a local var table for each top level definition
defn map-with-var-table (f:(ETExp, VarTable) -> ETExp, gvt:VarTable, epackage:EPackage) :
  val exps* = for e in exps(epackage) map :
    f(e, LocalVarTable(gvt, e))
  sub-exps(epackage, exps*)

defn map-with-var-table (f:(ETExp, VarTable) -> ETExp, gvt:VarTable, epackage:EPackage, enabled?:Int -> True|False) :
  val exps* = for e in exps(epackage) map :
    match(e:EInit|EDefn|EDefmethod) :
      f(e, LocalVarTable(gvt, e)) when enabled?(n(e)) else e
    else : e
  sub-exps(epackage, exps*)

;Rename all variables and type variables
defn rename-vars+tvars<?T> (e:ELItem&?T, table:IntTable<Int>) -> T :
  defn rename (e:ELItem) :
    defn f (x:Int) : get?(table, x, x)
    match(map(rename,e)) :
      (e:EDefClosure) : EDefClosure(n(e), f(closure(e)), ntargs(e), nargs(e), func(e))
      (e:EDefmulti) : EDefmulti(n(e), map(f,targs(e)), a1(e), a2(e), info(e))
      (e:EFn) : EFn(tail?(e), map(f,targs(e)), map(f,args(e)), a1(e), a2(e), body(e), info(e), free?(e))
      (e:EMethod) : EMethod(multi(e), targs(e), f(thisn(e)), func(e))
      (e:EVar) : EVar(f(n(e)))
      (e:EVarLoc) : EVarLoc(f(n(e)))
      (e:ETVar) : ETVar(f(n(e)))
      (e:ETVarLoc) : ETVarLoc(f(n(e)))
      (e) : e
  rename(e) as ELItem&T

;Substitute tvars for types
defn sub-tvars (t:EType, table:IntTable<EType>) :
  let loop (t:EType = t) :
    match(t:ETVar) : get?(table, n(t), t)
    else : map(loop, t)

;Type variable removal
defn remove-tvars<?T> (e:ELItem&?T) :
  defn loop (e:ELItem) -> ELItem :
    match(e) :
      (e:ETVar) : ETop()
      (e:ELItem) : map(loop, e)
  loop(e) as ELItem&T

;Check whether type has type variable
defn has-tvar? (t:EType) :
  var tvar? = false
  let loop (t:EType = t) :
    match(t:ETVar) : tvar? = true
    else : do*(loop, t)
  tvar?

public defn select<?T> (xs:Tuple<?T>, mask:Tuple<True|False>) -> Tuple<T> :
  to-tuple(filter(xs, mask))
